"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.DataStreams = void 0;
const transport_1 = require("@zcatalyst/transport");
const utils_1 = require("@zcatalyst/utils");
const errors_1 = require("./utils/errors");
const { COMPONENT, REQ_METHOD, CREDENTIAL_USER } = utils_1.CONSTANTS;
class DataStreams {
    constructor(app) {
        this.requester = new transport_1.Handler(app, this);
    }
    getComponentName() {
        return COMPONENT.data_streams;
    }
    async getAllChannels() {
        try {
            const request = {
                method: REQ_METHOD.get,
                path: '/datastreams/channel',
                user: CREDENTIAL_USER.admin,
                service: "baas",
                type: "json",
                expecting: "json"
            };
            const resp = await this.requester.send(request);
            return resp.data.data;
        }
        catch (error) {
            throw new errors_1.CatalystDataStreamError('FAILED_TO_GET_CHANNELS', `Failed to get all channels: ${error instanceof Error ? error.message : 'Unknown error'}`);
        }
    }
    async getChannelDetails(channelId) {
        await (0, utils_1.wrapValidatorsWithPromise)(() => {
            (0, utils_1.isValidInputString)(channelId, 'channelId', true);
        }, errors_1.CatalystDataStreamError);
        try {
            const request = {
                method: REQ_METHOD.get,
                path: `/datastreams/channel/${channelId}`,
                user: CREDENTIAL_USER.admin,
                service: "baas",
                type: "json",
                expecting: "json"
            };
            const resp = await this.requester.send(request);
            return resp.data.data;
        }
        catch (error) {
            throw new errors_1.CatalystDataStreamError('FAILED_TO_GET_CHANNEL_DETAILS', `Failed to get channel details: ${error instanceof Error ? error.message : 'Unknown error'}`);
        }
    }
    async getLiveCount(channelId) {
        await (0, utils_1.wrapValidatorsWithPromise)(() => {
            (0, utils_1.isValidInputString)(channelId, 'channelId', true);
        }, errors_1.CatalystDataStreamError);
        try {
            const request = {
                method: REQ_METHOD.get,
                path: `/datastreams/channel/${channelId}/liveclient`,
                user: CREDENTIAL_USER.admin,
                service: "baas",
                type: "json",
                expecting: "json"
            };
            const resp = await this.requester.send(request);
            return resp.data;
        }
        catch (error) {
            throw new errors_1.CatalystDataStreamError('FAILED_TO_GET_LIVE_COUNT', `Failed to get live count: ${error instanceof Error ? error.message : 'Unknown error'}`, error);
        }
    }
    async publishData(channelId, data) {
        await (0, utils_1.wrapValidatorsWithPromise)(() => {
            (0, utils_1.isValidInputString)(channelId, 'channelId', true);
            (0, utils_1.isNonEmptyObject)(data, 'data', true);
        }, errors_1.CatalystDataStreamError);
        try {
            const payload = data;
            const request = {
                method: REQ_METHOD.post,
                path: `/datastreams/channel/${channelId}/stream`,
                data: { data: payload },
                user: CREDENTIAL_USER.admin,
                service: "baas",
                type: "json",
                expecting: "json"
            };
            const resp = await this.requester.send(request);
            return resp;
        }
        catch (error) {
            throw new errors_1.CatalystDataStreamError('FAILED_TO_PUBLISH_DATA', `Failed to publish data: ${error instanceof Error ? error.message : 'Unknown error'}`, error);
        }
    }
    async getTokenPair(channelId, { userId, connectionName }) {
        await (0, utils_1.wrapValidatorsWithPromise)(() => {
            (0, utils_1.isValidInputString)(channelId, 'channelId', true);
            if (!(0, utils_1.isValidInputString)(userId, 'userId', false) &&
                !(0, utils_1.isValidInputString)(connectionName, 'connectionName', false)) {
                throw new errors_1.CatalystDataStreamError('INVALID_USER_IDENTIFIER', 'User identifier or connection name must be a non-empty string');
            }
        }, errors_1.CatalystDataStreamError);
        try {
            let payload = {};
            if (userId) {
                payload = { app_user_id: userId };
            }
            else if (connectionName) {
                payload = { connection_name: connectionName };
            }
            const request = {
                method: REQ_METHOD.post,
                path: `/datastreams/channel/${channelId}/tokenpair`,
                user: CREDENTIAL_USER.user,
                data: payload,
                service: "baas",
                type: "json",
                expecting: "json"
            };
            const resp = await this.requester.send(request);
            return resp.data.data;
        }
        catch (error) {
            throw new errors_1.CatalystDataStreamError('FAILED_TO_GET_TOKEN_PAIR', `Failed to get token pair: ${error instanceof Error ? error.message : 'Unknown error'}`, error);
        }
    }
}
exports.DataStreams = DataStreams;
