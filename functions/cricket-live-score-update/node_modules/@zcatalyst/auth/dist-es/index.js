var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _ZCAuth_instances, _ZCAuth_appCollection, _ZCAuth_loadOptionsFromObj, _ZCAuth_loadOptionsFromEnvVar;
import { CatalystAppError, CatalystError, CONSTANTS, isNonEmptyObject, isNonEmptyString, isNonEmptyStringOrNumber, isNonNullObject, isValidType, ObjectHasProperties } from '@zcatalyst/utils';
import { readFileSync } from 'fs';
import { AccessTokenCredential, ApplicationDefaultCredential, CatalystCredential, RefreshTokenCredential, TicketCredential } from './credential';
const { INIT_TYPE, PROJECT_HEADER, DEFAULT_ENV, CATALYST_CONFIG_ENV_KEY, DEFAULT_APP_NAME, CREDENTIAL_USER, CATALYST_ORIGIN, AUTH_HEADER, COOKIE_HEADER, CREDENTIAL_HEADER } = CONSTANTS;
let appOptions = {};
export class ZCAuth {
    constructor() {
        _ZCAuth_instances.add(this);
        this.config = {};
        _ZCAuth_appCollection.set(this, {});
    }
    init(options, { type, appName, scope } = {
        type: 'auto'
    }) {
        switch (type) {
            case INIT_TYPE.advancedio:
                if (!options || typeof options.headers !== 'object') {
                    throw new CatalystAppError('INVALID_PROJECT_OPTIONS', 'the options passed to initialize method is not valid', options);
                }
                appOptions = __classPrivateFieldGet(this, _ZCAuth_instances, "m", _ZCAuth_loadOptionsFromObj).call(this, options['headers']);
                appOptions.credential = new CatalystCredential(options['headers']);
                break;
            case INIT_TYPE.basicio:
                if (!options || typeof options.catalystHeaders !== 'object') {
                    throw new CatalystAppError('INVALID_PROJECT_OPTIONS', 'the options passed to initialize method is not valid', options);
                }
                appOptions = __classPrivateFieldGet(this, _ZCAuth_instances, "m", _ZCAuth_loadOptionsFromObj).call(this, options['catalystHeaders']);
                appOptions.credential = new CatalystCredential(options['catalystHeaders']);
                break;
            case INIT_TYPE.custom:
                if (!options || !options['credential']) {
                    throw new CatalystAppError('INVALID_PROJECT_OPTIONS', 'the options passed to initialize method is not valid', options);
                }
                appOptions = options;
                break;
            default:
                if (options && typeof options.headers === 'object') {
                    return this.init(options, { type: INIT_TYPE.advancedio, appName, scope });
                }
                if (options && typeof options.catalystHeaders === 'object') {
                    return this.init(options, { type: INIT_TYPE.basicio, appName, scope });
                }
                if (options && options['credential']) {
                    return this.init(options, { type: INIT_TYPE.custom, appName, scope });
                }
                throw new CatalystAppError('APP_ERROR', 'Unable to find the type of initialisation. kindly specify one', options);
        }
        const catalystApp = new CatalystApp(appOptions);
        if (appName !== undefined && isNonEmptyString(appName)) {
            __classPrivateFieldGet(this, _ZCAuth_appCollection, "f")[appName] = catalystApp;
        }
        else {
            __classPrivateFieldGet(this, _ZCAuth_appCollection, "f")[DEFAULT_APP_NAME] = catalystApp;
        }
        return catalystApp;
    }
    getDefaultCredentials(appName) {
        if (typeof appName === 'undefined') {
            appName = DEFAULT_APP_NAME;
        }
        if (!isNonEmptyObject(appOptions)) {
            appOptions = __classPrivateFieldGet(this, _ZCAuth_instances, "m", _ZCAuth_loadOptionsFromEnvVar).call(this);
            if (!isNonEmptyObject(appOptions)) {
                throw new CatalystAppError('AUTH_ERROR', 'Unable to get the app credentials, please initialize the app before perform operations.', appOptions);
            }
        }
        if (typeof appOptions.credential === 'undefined') {
            appOptions.credential = new ApplicationDefaultCredential();
        }
        const app = new CatalystApp(appOptions);
        app.credential.switchUser(CREDENTIAL_USER.admin);
        __classPrivateFieldGet(this, _ZCAuth_appCollection, "f")[appName] = app;
        return app;
    }
    app(appName) {
        if (typeof appName === 'undefined') {
            appName = DEFAULT_APP_NAME;
        }
        if (!isNonEmptyString(appName)) {
            throw new CatalystAppError('INVALID_PROJECT_NAME', 'Invalid app name provided. App name must be a non-empty string.', appName);
        }
        else if (!(appName in __classPrivateFieldGet(this, _ZCAuth_appCollection, "f"))) {
            let errorMessage = appName === DEFAULT_APP_NAME
                ? 'The default project does not exist. '
                : `project named "${appName}" does not exist. `;
            errorMessage += 'Make sure you call init() before getting the desired app';
            throw new CatalystAppError('no_app', errorMessage, appName);
        }
        return __classPrivateFieldGet(this, _ZCAuth_appCollection, "f")[appName];
    }
}
_ZCAuth_appCollection = new WeakMap(), _ZCAuth_instances = new WeakSet(), _ZCAuth_loadOptionsFromObj = function _ZCAuth_loadOptionsFromObj(obj) {
    const projectId = obj[PROJECT_HEADER.id];
    const projectKey = obj[PROJECT_HEADER.key];
    const environment = obj[PROJECT_HEADER.environment] || DEFAULT_ENV;
    const projectDomain = obj[PROJECT_HEADER.domain] || CATALYST_ORIGIN;
    const projectSecretKey = obj[PROJECT_HEADER.projectSecretKey];
    if (!projectKey || !projectId) {
        throw new CatalystAppError('PROJECT_ERROR', 'Invalid project details. Failed to parse an object.', obj);
    }
    return {
        projectId,
        projectKey,
        environment,
        projectDomain,
        projectSecretKey
    };
}, _ZCAuth_loadOptionsFromEnvVar = function _ZCAuth_loadOptionsFromEnvVar() {
    const config = process.env[CATALYST_CONFIG_ENV_KEY];
    if (!isNonEmptyString(config)) {
        return {};
    }
    try {
        const contents = config.startsWith('{')
            ? config
            : readFileSync(config, 'utf8');
        return JSON.parse(contents);
    }
    catch (err) {
        throw new CatalystAppError('INVALID_PROJECT_OPTIONS', 'Failed to parse app options : ' + err, err);
    }
};
export class CatalystApp {
    constructor(options) {
        try {
            isNonNullObject(options, 'options', true);
            ObjectHasProperties(options, ['credential'], 'options', true);
            isNonNullObject(options.credential, 'options.credential', true);
            isValidType(options.credential.getToken, 'function', 'options.credential', true);
            isNonEmptyStringOrNumber(options.project_id || options.projectId, 'projectId', true);
        }
        catch (e) {
            if (e instanceof CatalystError) {
                throw new CatalystAppError(e.code, e.message, e);
            }
            throw e;
        }
        this.credential = options.credential;
        this.config = {
            projectId: (options.project_id || options.projectId) + '',
            projectKey: (options.project_key || options.projectKey),
            projectDomain: (options.project_domain || options.projectDomain),
            environment: options.environment,
            projectSecretKey: (options.project_secret_key || options.projectSecretKey)
        };
    }
    setOauthHeader(headers, token) {
        headers[AUTH_HEADER] = 'Zoho-oauthtoken ' + token;
    }
    setTicketHeader(headers, token) {
        headers[AUTH_HEADER] = 'Zoho-ticket ' + token;
    }
    async authenticateRequest(req) {
        const headers = Object.assign({}, req.headers);
        if (this.credential instanceof AccessTokenCredential ||
            this.credential instanceof RefreshTokenCredential) {
            const token = await this.credential.getToken();
            this.setOauthHeader(headers, token.access_token);
            req.headers = headers;
            return;
        }
        if (this.credential instanceof TicketCredential) {
            const token = await this.credential.getToken();
            this.setTicketHeader(headers, token.ticket);
            req.headers = headers;
            return;
        }
        if (this.credential instanceof CatalystCredential ||
            this.credential instanceof ApplicationDefaultCredential) {
            const token = (await this.credential.getToken());
            if (isNonEmptyString(token.access_token)) {
                this.setOauthHeader(headers, token.access_token);
            }
            else if (isNonEmptyString(token.ticket)) {
                this.setTicketHeader(headers, token.ticket);
            }
            else if (isNonEmptyString(token.cookie)) {
                headers[COOKIE_HEADER] = token.cookie;
                headers[CREDENTIAL_HEADER.zcsrf] = token.zcrf_header;
            }
            req.headers = headers;
        }
    }
}
export { AccessTokenCredential, Credential, RefreshTokenCredential, TicketCredential } from './credential';
export { CatalystAppError };
