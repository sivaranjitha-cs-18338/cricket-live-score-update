'use strict';
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ApplicationDefaultCredential = exports.CatalystCredential = exports.CookieCredential = exports.TicketCredential = exports.AccessTokenCredential = exports.RefreshTokenCredential = exports.Credential = exports.globalValue = void 0;
const utils_1 = require("@zcatalyst/utils");
const fs_1 = require("fs");
const http_1 = __importDefault(require("http"));
const https_1 = __importDefault(require("https"));
const path_1 = require("path");
const querystring_1 = require("querystring");
const errors_1 = require("./errors");
const { CREDENTIAL_SUFFIX, CATALYST_AUTH_ENV_KEY, REQ_METHOD, CREDENTIAL_HEADER, CREDENTIAL_TYPE, CREDENTIAL_USER, CSRF_TOKEN_NAME, ACCOUNTS_ORIGIN } = utils_1.CONSTANTS;
exports.globalValue = {};
const CREDENTIAL_PATH = process.env.HOME
    ? (0, path_1.resolve)((0, path_1.resolve)(process.env.HOME, '.config'), CREDENTIAL_SUFFIX)
    : (0, path_1.resolve)('.', CREDENTIAL_SUFFIX);
function getAttr(from, key, alt) {
    const tmp = from[key] || (alt ? from[alt] : undefined);
    if (typeof tmp === 'undefined') {
        throw new errors_1.CatalystAuthError('INVALID_CREDENTIAL', `Unable to get ${alt} from credential Object provided`, from);
    }
    return tmp;
}
function fromPath(filePath) {
    let jsonString;
    try {
        jsonString = (0, fs_1.readFileSync)(filePath, 'utf8');
    }
    catch (ignored) {
        return null;
    }
    try {
        return JSON.parse(jsonString);
    }
    catch (err) {
        throw new errors_1.CatalystAuthError('INVALID_CREDENTIAL', 'Failed to parse token file: ' + err, err);
    }
}
function fromEnv() {
    const jsonString = process.env[CATALYST_AUTH_ENV_KEY];
    if (jsonString === undefined) {
        return null;
    }
    try {
        return JSON.parse(jsonString);
    }
    catch (err) {
        throw new errors_1.CatalystAuthError('INVALID_CREDENTIAL', 'Failed to parse refresh token string from env: ' + err, err);
    }
}
function _appendQueryData(url, data) {
    if (data && Object.keys(data).length > 0) {
        url += url.includes('?') ? '&' : '?';
        url += (0, querystring_1.stringify)(data);
    }
    return url;
}
function isHttps(url) {
    if (url === undefined) {
        return false;
    }
    const parsedUrl = url instanceof URL ? url : new URL(url);
    return parsedUrl.protocol !== 'http:';
}
async function _request(config) {
    config.url = _appendQueryData(String(config.origin) + String(config.path), config.qs);
    const parsedUrl = new URL(config.url);
    if (parsedUrl.hostname === null) {
        throw new errors_1.CatalystAuthError('unparsable_config', 'Hostname cannot be null', config.path);
    }
    const isHttpsProtocol = isHttps(parsedUrl);
    parsedUrl.searchParams?.sort();
    const options = {
        hostname: parsedUrl.hostname,
        port: parsedUrl.port,
        path: parsedUrl.pathname + parsedUrl.search,
        method: config.method,
        headers: {
            'Content-Type': 'application/json',
            ...(config.headers || {})
        }
    };
    const transport = isHttpsProtocol ? https_1.default : http_1.default;
    return new Promise((resolve, reject) => {
        const req = transport.request(options, (res) => {
            const chunks = [];
            res.on('data', (chunk) => {
                chunks.push(chunk);
            });
            res.on('end', () => {
                const body = Buffer.concat(chunks).toString();
                const response = {
                    headers: res.headers,
                    request: req,
                    stream: res,
                    statusCode: res.statusCode,
                    config,
                    body
                };
                resolve(response);
            });
        });
        req.on('error', (err) => {
            reject(err);
        });
        req.write(JSON.stringify({ your: 'data' }));
        req.end();
    });
}
async function requestAccessToken(request) {
    const options = {
        method: request.method,
        origin: request.origin,
        qs: request.qs,
        path: request.path
    };
    const resp = await _request(options);
    const json = JSON.parse(resp.body);
    if (json.error) {
        const errorMessage = 'Error fetching access token: ' + json.error;
        return Promise.reject(errorMessage);
    }
    else if (!json.access_token || !json.expires_in) {
        return Promise.reject(`Unexpected response while fetching access token: ${JSON.stringify(json)}`);
    }
    else {
        return json;
    }
}
class Credential {
    getCurrentUser() {
        return CREDENTIAL_USER.admin;
    }
    switchUser(_givenUser) {
        return null;
    }
    getCurrentUserType() {
        return CREDENTIAL_USER.admin;
    }
}
exports.Credential = Credential;
class RefreshTokenCredential extends Credential {
    constructor(refreshObj) {
        super();
        this.clientId = getAttr(refreshObj, 'clientId', 'client_id');
        this.clientSecret = getAttr(refreshObj, 'clientSecret', 'client_secret');
        this.refreshToken = getAttr(refreshObj, 'refreshToken', 'refresh_token');
        this.cachedToken = null;
    }
    async getToken() {
        if (this.cachedToken === null || this.cachedToken['expires_in'] <= Date.now()) {
            const token = await requestAccessToken({
                method: REQ_METHOD.post,
                origin: ACCOUNTS_ORIGIN,
                path: '/oauth/v2/token',
                qs: {
                    client_id: this.clientId,
                    client_secret: this.clientSecret,
                    refresh_token: this.refreshToken,
                    grant_type: 'refresh_token'
                }
            });
            this.cachedToken = token;
            this.cachedToken.expires_in = Date.now() + token.expires_in * 1000;
        }
        return this.cachedToken;
    }
}
exports.RefreshTokenCredential = RefreshTokenCredential;
class AccessTokenCredential extends Credential {
    constructor(accessObj) {
        super();
        this.accessToken = getAttr(accessObj, 'accessToken', 'access_token');
    }
    async getToken() {
        return Promise.resolve({
            access_token: this.accessToken
        });
    }
}
exports.AccessTokenCredential = AccessTokenCredential;
class TicketCredential extends Credential {
    constructor(ticketObj) {
        super();
        this.ticket = getAttr(ticketObj, 'ticket', 'ticket');
    }
    async getToken() {
        return Promise.resolve({ ticket: this.ticket });
    }
}
exports.TicketCredential = TicketCredential;
class CookieCredential extends Credential {
    constructor(cookieObj) {
        super();
        this.cookie = getAttr(cookieObj, 'cookie', 'cookie');
        this.cookieObj = {};
    }
    getAsObject() {
        if (Object.keys(this.cookieObj).length > 0) {
            return this.cookieObj;
        }
        this.cookie.split(';').forEach((cookie) => {
            const parts = cookie.split('=');
            this.cookieObj[parts.shift()?.trim()] = decodeURI(parts.join('='));
        });
        return this.cookieObj;
    }
    getZCSRFHeader() {
        const cookieObj = this.getAsObject();
        return 'zd_csrparam=' + cookieObj[CSRF_TOKEN_NAME];
    }
    async getToken() {
        return Promise.resolve({ cookie: this.cookie, zcrf_header: this.getZCSRFHeader() });
    }
}
exports.CookieCredential = CookieCredential;
class CatalystCredential extends Credential {
    constructor(credObj, scope) {
        super();
        this.adminCredType = getAttr(credObj, 'adminType', CREDENTIAL_HEADER.admin_cred_type);
        this.adminToken = getAttr(credObj, 'adminToken', CREDENTIAL_HEADER.admin_token);
        this.userCredType = credObj[CREDENTIAL_HEADER.user_cred_type];
        this.userToken = credObj[CREDENTIAL_HEADER.user_token];
        this.cookieStr = credObj[CREDENTIAL_HEADER.cookie];
        this.userType =
            credObj[CREDENTIAL_HEADER.user] === CREDENTIAL_USER.admin
                ? CREDENTIAL_USER.admin
                : CREDENTIAL_USER.user;
        this.currentUser = scope || this.userType;
        if (this.userToken === undefined && this.cookieStr === undefined) {
            throw new errors_1.CatalystAuthError('INVALID_CREDENTIAL', 'missing user credentials', credObj);
        }
        switch (this.adminCredType) {
            case CREDENTIAL_TYPE.ticket:
                this.adminCred = new TicketCredential({ ticket: this.adminToken });
                break;
            case CREDENTIAL_TYPE.token:
                this.adminCred = new AccessTokenCredential({ access_token: this.adminToken });
                break;
            default:
                throw new errors_1.CatalystAuthError('INVALID_CREDENTIAL', 'admin credential type is unknown', credObj);
        }
        switch (this.userCredType) {
            case CREDENTIAL_TYPE.ticket:
                this.userCred = new TicketCredential({ ticket: this.userToken });
                break;
            case CREDENTIAL_TYPE.token:
                this.userCred = new AccessTokenCredential({
                    access_token: this.userToken
                });
                break;
            default:
                if (this.cookieStr !== undefined) {
                    this.userCred = new CookieCredential({
                        cookie: this.cookieStr
                    });
                }
        }
    }
    async getToken() {
        switch (this.currentUser) {
            case CREDENTIAL_USER.admin:
                return this.adminCred.getToken();
            case CREDENTIAL_USER.user:
                if (this.userCred === undefined) {
                    throw new errors_1.CatalystAuthError('INVALID_CREDENTIAL', 'User Credential is not initialised', this.currentUser);
                }
                return this.userCred.getToken();
            default:
                throw new errors_1.CatalystAuthError('INVALID_CREDENTIAL', 'user provided is not recognized', this.currentUser);
        }
    }
    getCurrentUser() {
        return this.currentUser;
    }
    getCurrentUserType() {
        if (this.currentUser === CREDENTIAL_USER.user) {
            return this.userType;
        }
        return this.currentUser;
    }
    switchUser(givenUser) {
        if (givenUser === undefined) {
            switch (this.currentUser) {
                case CREDENTIAL_USER.admin:
                    givenUser = CREDENTIAL_USER.user;
                    break;
                case CREDENTIAL_USER.user:
                    givenUser = CREDENTIAL_USER.admin;
                    break;
            }
        }
        this.currentUser = givenUser;
        return this.currentUser;
    }
}
exports.CatalystCredential = CatalystCredential;
class ApplicationDefaultCredential extends Credential {
    constructor() {
        super();
        let token = fromPath(CREDENTIAL_PATH);
        if (token === undefined || token === null) {
            token = fromEnv();
        }
        if (token === undefined || token === null) {
            throw new errors_1.CatalystAuthError('INVALID_CREDENTIAL', 'Unable to get token object from path or env', token);
        }
        if ('refresh_token' in token) {
            this.credential = new RefreshTokenCredential(token);
        }
        else if ('access_token' in token) {
            this.credential = new AccessTokenCredential(token);
        }
        else if ('ticket' in token) {
            this.credential = new TicketCredential(token);
        }
        else {
            throw new errors_1.CatalystAuthError('INVALID_CREDENTIAL', 'The given token object does not contain proper credentials', token);
        }
    }
    async getToken() {
        return this.credential.getToken();
    }
}
exports.ApplicationDefaultCredential = ApplicationDefaultCredential;
