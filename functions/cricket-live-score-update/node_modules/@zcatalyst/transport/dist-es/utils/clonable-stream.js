'use strict';
import { nextTick } from 'process';
import { PassThrough } from 'stream';
function clonePiped(that) {
    if (--that._clonesCount === 0 && !that.destroyed) {
        that._original?.pipe(that);
        that._original = undefined;
    }
}
function _destroy(error, callback) {
    if (!error) {
        this.push(null);
        this.end();
    }
    nextTick(callback, error);
}
function forwardDestroy(src, dest) {
    function destroy(err) {
        src.removeListener('close', onClose);
        dest.destroy(err);
    }
    function onClose() {
        dest.end();
    }
    src.on('error', destroy);
    src.on('close', onClose);
}
class StreamClone extends PassThrough {
    constructor(parent) {
        super({ objectMode: parent.readableObjectMode });
        this.parent = parent;
        forwardDestroy(parent, this);
        parent._internalPipe = true;
        parent.pipe(this);
        parent._internalPipe = false;
        this.on('newListener', this.onDataClone);
        this.once('resume', this.onResumeClone);
    }
    onDataClone(event, _listener) {
        if (event === 'data' || event === 'readable' || event === 'close') {
            nextTick(clonePiped, this.parent);
            this.removeListener('newListener', this.onDataClone);
            this.removeListener('resume', this.onResumeClone);
        }
    }
    onResumeClone() {
        this.removeListener('newListener', this.onDataClone);
        this.removeListener('resume', this.onResumeClone);
        nextTick(clonePiped, this.parent);
    }
    clone() {
        return this.parent.clone();
    }
    isCloneable(stream) {
        return stream instanceof CloneableStream || stream instanceof StreamClone;
    }
}
export default class CloneableStream extends PassThrough {
    constructor(stream) {
        super({ objectMode: stream.readableObjectMode });
        this._original = stream;
        this._clonesCount = 1;
        this._internalPipe = false;
        forwardDestroy(stream, this);
        this.on('newListener', this.onData);
        this.on('resume', this.onResume);
        this._hasListener = true;
        this._destroy = _destroy;
    }
    onData(event, _listener) {
        if (event === 'data' || event === 'readable') {
            this._hasListener = false;
            this.removeListener('newListener', this.onData);
            this.removeListener('resume', this.onResume);
            nextTick(clonePiped, this);
        }
    }
    onResume() {
        this._hasListener = false;
        this.removeListener('newListener', this.onData);
        this.removeListener('resume', this.onResume);
        nextTick(clonePiped, this);
    }
    resume() {
        if (this._internalPipe) {
            return this;
        }
        PassThrough.prototype.resume.call(this);
        return this;
    }
    clone() {
        if (!this._original) {
            throw new Error('already started');
        }
        this._clonesCount++;
        this.removeListener('newListener', this.onData);
        this.removeListener('resume', this.onResume);
        const clone = new StreamClone(this);
        if (this._hasListener) {
            this.on('newListener', this.onData);
            this.on('resume', this.onResume);
        }
        return clone;
    }
}
