'use strict';
import { basename } from 'path';
import { Readable, Stream } from 'stream';
import { inspect } from 'util';
import CloneableStream from './clonable-stream';
class FormData extends Stream {
    constructor(streams) {
        super();
        this.writable = false;
        this.readable = true;
        this.released = false;
        this.streams = streams || [];
        this.insideLoop = false;
        this.pendingNext = false;
    }
    isStream(value) {
        return (value !== undefined &&
            value !== null &&
            ((typeof value.on === 'function' &&
                typeof value.pipe === 'function') ||
                value instanceof Readable));
    }
    _multiPartHeader(field, value) {
        const contentDisposition = this._getContentDisposition(value);
        const contentType = this._getContentType(value);
        let contents = '';
        const headers = {
            'Content-Disposition': ['form-data', 'name="' + field + '"'].concat(contentDisposition || []),
            'Content-Type': [contentType]
        };
        for (const prop in headers) {
            if (headers[prop]) {
                const header = headers[prop];
                if (header.length > 0) {
                    contents += prop + ': ' + header.join('; ') + FormData.LINE_BREAK;
                }
            }
        }
        return '--' + this.getBoundary() + FormData.LINE_BREAK + contents + FormData.LINE_BREAK;
    }
    _getContentDisposition(value) {
        let filename = '';
        let contentDisposition = '';
        if (value['name'] || value['path']) {
            filename = basename(value['name'] || value['path']);
        }
        else if (value['readable'] && value.hasOwnProperty('httpVersion')) {
            filename = basename(value['client']._httpMessage.path || '');
        }
        if (filename) {
            contentDisposition = 'filename="' + filename + '"';
        }
        return contentDisposition;
    }
    _getContentType(value) {
        let contentType = '';
        if (value.readable && value.hasOwnProperty('httpVersion')) {
            contentType = value.headers['content-type'];
        }
        if (!contentType) {
            contentType = FormData.CONTENT_TYPE;
        }
        return contentType;
    }
    _lastBoundary() {
        return '--' + this.getBoundary() + '--' + FormData.LINE_BREAK;
    }
    _generateBoundary() {
        let boundary = '--------------------------';
        for (let i = 0; i < 24; i++) {
            boundary += Math.floor(Math.random() * 10).toString(16);
        }
        this.boundary = boundary;
        return boundary;
    }
    _error(err) {
        this._reset();
        this.emit('error', err);
    }
    _handleStreamErrors(stream) {
        stream.on('error', (err) => {
            this._error(err);
        });
    }
    _pipeNext(stream) {
        this.currentStream = stream;
        if (this.isStream(stream)) {
            stream.on('end', this._getNext.bind(this));
            stream.pipe(this, {
                end: false
            });
            return;
        }
        const value = stream;
        this.write(value);
        this._getNext();
    }
    _getNext() {
        this.currentStream = undefined;
        if (this.insideLoop) {
            this.pendingNext = true;
            return;
        }
        this.insideLoop = true;
        try {
            do {
                this.pendingNext = false;
                const stream = this.streams.shift();
                if (typeof stream === 'undefined') {
                    this.end();
                }
                else {
                    this._pipeNext(stream);
                }
            } while (this.pendingNext);
        }
        finally {
            this.insideLoop = false;
        }
    }
    _reset() {
        this.writable = false;
        this.streams = [];
        this.currentStream = undefined;
    }
    createClone() {
        const newStreams = [];
        this.streams.forEach((stream) => {
            const clone = this.isStream(stream)
                ? new CloneableStream(stream).clone()
                : stream;
            newStreams.push(clone);
        });
        return new FormData(newStreams);
    }
    append(field, value) {
        if (Array.isArray(value)) {
            this._error(new Error('Arrays are not supported.'));
            return this;
        }
        if (typeof value !== 'string' && !Buffer.isBuffer(value) && !this.isStream(value)) {
            value = inspect(value);
        }
        if (this.isStream(value)) {
            this._handleStreamErrors(value);
        }
        this.streams.push(this._multiPartHeader(field, value));
        this.streams.push(value);
        this.streams.push(FormData.LINE_BREAK);
        return this;
    }
    getHeaders(userHeaders) {
        const formHeaders = {};
        for (const header in userHeaders) {
            if (userHeaders[header]) {
                formHeaders[header.toLowerCase()] = userHeaders[header];
            }
        }
        formHeaders['content-type'] = 'multipart/form-data; boundary=' + this.getBoundary();
        return formHeaders;
    }
    getBoundary() {
        if (this.boundary === undefined) {
            return this._generateBoundary();
        }
        return this.boundary;
    }
    pipe(dest, options) {
        Stream.prototype.pipe.call(this, dest, options);
        this.resume();
        return dest;
    }
    write(data) {
        const lastPart = this.streams.length === 0;
        this.emit('data', data);
        if (lastPart) {
            this.emit('data', this._lastBoundary());
        }
        return true;
    }
    pause() {
        if (this.currentStream !== undefined &&
            typeof this.currentStream.pause === 'function') {
            this.currentStream.pause();
        }
        this.emit('pause');
    }
    resume() {
        if (!this.released) {
            this.released = true;
            this.writable = true;
            this._getNext();
        }
        if (this.currentStream && typeof this.currentStream.resume === 'function') {
            this.currentStream.resume();
        }
        this.emit('resume');
    }
    end() {
        this._reset();
        this.emit('end');
    }
    destroy() {
        this._reset();
        this.emit('close');
    }
    toString() {
        return '[object FormData]';
    }
}
FormData.LINE_BREAK = '\r\n';
FormData.CONTENT_TYPE = 'application/octet-stream';
export default FormData;
