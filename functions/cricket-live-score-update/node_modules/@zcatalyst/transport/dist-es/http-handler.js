'use strict';
import { CONSTANTS, getServicePath, isNonEmptyString, LOGGER } from '@zcatalyst/utils';
import http from 'http';
import https from 'https';
import { ReadableStream } from 'node:stream/web';
import { stringify } from 'querystring';
import { Readable } from 'stream';
import { URL } from 'url';
import { inspect } from 'util';
import { version } from '../package.json';
import { CatalystAPIError } from './utils/errors';
import FORM from './utils/form-data';
import { isHttps } from './utils/helpers';
import RequestAgent from './utils/request-agent';
const { PROJECT_KEY_NAME, IS_LOCAL, ENVIRONMENT_KEY_NAME, ENVIRONMENT, USER_KEY_NAME, CREDENTIAL_USER, CATALYST_ORIGIN, X_ZOHO_CATALYST_ORG_ID, USER_AGENT, APM_INSIGHT, ACCEPT_HEADER, REQ_RETRY_THRESHOLD, PROJECT_HEADER, IS_APM, X_ZOHO_CATALYST_RESOURCE_ID } = CONSTANTS;
export class DefaultHttpResponse {
    constructor(resp) {
        this.statusCode = resp.statusCode;
        this.headers = resp.headers;
        this.config = resp.config;
        this.resp = resp;
    }
    get data() {
        switch (this.config.expecting) {
            case "string":
                if (this.resp.data === undefined) {
                    throw new CatalystAPIError('UNPARSABLE_RESPONSE', `Error while processing response data. Raw server ` +
                        `response: "${this.resp.data}". Status code: "${this.statusCode}".`, '', this.statusCode);
                }
                return this.resp.data;
            case "buffer":
                if (this.resp.buffer === undefined) {
                    throw new CatalystAPIError('UNPARSABLE_RESPONSE', `Error while processing response buffer. Raw server ` +
                        `response: "${this.resp.data}". Status code: "${this.statusCode}".`, '', this.statusCode);
                }
                return this.resp.buffer;
            case "raw":
                return this.resp.stream;
            default:
                try {
                    return JSON.parse(this.resp.data);
                }
                catch (e) {
                    throw new CatalystAPIError('UNPARSABLE_RESPONSE', `Error while parsing response data: "${inspect(e)}". Raw server ` +
                        `response: "${this.resp.data}". Status code: "${this.statusCode}".`, '', this.statusCode);
                }
        }
    }
}
function rejectWithContext(reject, statusCode, data) {
    try {
        const catalystError = JSON.parse(data);
        reject({
            statusCode,
            code: catalystError.data.error_code,
            message: catalystError.data.message
        });
        return;
    }
    catch (err) {
        reject({
            statusCode,
            message: inspect(data)
        });
    }
}
async function streamToBuffer(stream) {
    const chunks = [];
    return new Promise((resolve, reject) => {
        stream.destroyed && reject('Invalid response stream');
        stream.on('data', (chunk) => {
            chunks.push(chunk);
        });
        stream.on('error', reject);
        stream.on('end', () => resolve(Buffer.concat(chunks)));
    });
}
function constructFormData(data) {
    const formData = new FORM();
    const keyData = Object.keys(data);
    keyData.forEach((key) => {
        formData.append(key, data[key]);
    });
    return formData;
}
async function _finalizeRequest(resolve, reject, response) {
    if (response.statusCode === undefined) {
        reject(new CatalystAPIError('UNKNOWN_STATUSCODE', 'unable to obtain status code from response', response));
        return;
    }
    if (response.statusCode >= 200 && response.statusCode < 300) {
        resolve(response);
        return;
    }
    if (response.stream?.pipe === undefined) {
        rejectWithContext(reject, response.statusCode, response.data);
        return;
    }
    try {
        if (response.stream !== undefined && response.data === undefined) {
            const responseBuffer = await streamToBuffer(response.stream);
            response.data = responseBuffer.toString();
        }
        if (response.statusCode === 404) {
            rejectWithContext(reject, response.statusCode, response.data || 'Not Found');
        }
        else if (response.statusCode === 403) {
            rejectWithContext(reject, response.statusCode, response.data || 'Access Denied');
        }
        else if (response.statusCode === 401) {
            rejectWithContext(reject, response.statusCode, response.data || 'Unauthorized');
        }
        else {
            rejectWithContext(reject, response.statusCode, response.data || 'Unknown response');
        }
    }
    catch (e) {
        const errMsg = e instanceof Error ? e.message : inspect(e);
        rejectWithContext(reject, response.statusCode, errMsg);
    }
}
function _appendQueryData(url, data) {
    if (data && Object.keys(data).length > 0) {
        url += url.includes('?') ? '&' : '?';
        url += stringify(data);
    }
    return url;
}
async function _request(transport, options, config, data, retryCount = 0) {
    const clonedData = data === undefined
        ? undefined
        : config.type !== "file"
            ?
                data
            :
                data.createClone();
    return new Promise(async (resolve, reject) => {
        const retryRequest = async (err) => {
            LOGGER.warn('>>> RETRYING REQUEST ');
            if (retryCount++ === REQ_RETRY_THRESHOLD) {
                reject(err);
                return;
            }
            try {
                options.agent = new RequestAgent(isHttps(config.url), options.hostname, true).agent;
                const resp = await _request(transport, options, config, clonedData, retryCount);
                resolve(resp);
            }
            catch (e) {
                reject(e);
            }
        };
        const startTimeStamp = Date.now();
        const req = transport.request(options, async (res) => {
            if (req.destroyed) {
                return;
            }
            const response = {
                headers: res.headers,
                request: req,
                stream: res,
                statusCode: res.statusCode,
                config
            };
            LOGGER.debug(`>>> HTTP REQUEST : ${req.method?.toUpperCase()} ${req.protocol}//${req.host}${req.path}`);
            process.env.ZC_SECURE?.toLowerCase() === 'override' &&
                LOGGER.fine(`>>> REQUEST HEADERS : ${JSON.stringify(options.headers)}`);
            LOGGER.debug(`<<< HTTP RESPONSE : ${res.statusCode} : ${Date.now() - startTimeStamp} ms`);
            process.env.ZC_SECURE?.toLowerCase() === 'override' &&
                LOGGER.fine(`<<< RESPONSE HEADERS : ${JSON.stringify(res.headers)}`);
            if (config.expecting === "raw") {
                return _finalizeRequest(resolve, reject, response);
            }
            try {
                const responseBuffer = await streamToBuffer(res);
                response.data = responseBuffer.toString();
                response.buffer = responseBuffer;
            }
            catch (err) {
                if (req.destroyed || (config.abortSignal && config.abortSignal.aborted)) {
                    req.destroy();
                    return;
                }
                reject(err);
            }
            _finalizeRequest(resolve, reject, response);
        });
        req.on('error', (err) => {
            LOGGER.debug(`>>> HTTP REQUEST : ${req.method?.toUpperCase()} ${req.protocol}//${req.host}${req.path}`);
            process.env.ZC_SECURE?.toLowerCase() === 'override' &&
                LOGGER.fine(`>>> REQUEST HEADERS : ${JSON.stringify(options.headers)}`);
            LOGGER.debug(`<<< HTTP REQUEST ERROR : ${inspect(err)} : ${Date.now() - startTimeStamp} ms`);
            if (req.destroyed || config.type === "raw") {
                return reject(err);
            }
            retryRequest(err);
        });
        if (data === undefined) {
            req.end();
            return;
        }
        if (config.type !== "file" && config.type !== "raw") {
            req.write(data);
            req.end();
            return;
        }
        if (data instanceof ReadableStream) {
            data = webStreamToNodeStream(data);
        }
        data.on('error', (er) => {
            reject(er);
            req.end();
        });
        data.pipe(req).on('finish', req.end);
    });
}
function webStreamToNodeStream(webStream) {
    const reader = webStream.getReader();
    return new Readable({
        async read() {
            const { done, value } = await reader.read();
            if (done) {
                this.push(null);
            }
            else {
                this.push(value);
            }
        }
    });
}
async function sendRequest(config) {
    let data;
    let headers = Object.assign({
        [USER_AGENT.KEY]: USER_AGENT.PREFIX + version
    }, config.headers);
    if (config.data !== undefined) {
        switch (config.type) {
            case "json":
                data = JSON.stringify(config.data);
                headers['Content-Type'] = 'application/json';
                break;
            case "file":
                data = constructFormData(config.data);
                headers = data.getHeaders(headers);
                break;
            case "raw":
                data = config.data;
                if (headers['Content-Type'] === undefined) {
                    headers['Content-Type'] = 'application/octet-stream';
                }
                break;
            default:
                data = stringify(config.data);
                headers['Content-Type'] = 'application/x-www-form-urlencoded';
                headers['Content-Length'] = Buffer.byteLength(data) + '';
        }
    }
    const origin = config.origin || CATALYST_ORIGIN;
    config.url = config.url || new URL(config.path || '', origin).href;
    if (config.qs !== undefined) {
        config.url = _appendQueryData(config.url, config.qs);
    }
    const parsedUrl = new URL(config.url);
    if (parsedUrl.hostname === null) {
        throw new CatalystAPIError('UNPARSABLE_CONFIG', 'Hostname cannot be null', config.path, 400);
    }
    const isHttpsProtocol = isHttps(parsedUrl);
    const requestAgent = new RequestAgent(isHttpsProtocol, parsedUrl.hostname, false);
    parsedUrl.searchParams?.sort();
    const options = {
        hostname: parsedUrl.hostname,
        port: parsedUrl.port,
        path: parsedUrl.pathname + parsedUrl.search,
        method: config.method,
        headers,
        agent: requestAgent.agent
    };
    const transport = isHttpsProtocol ? https : http;
    return _request(transport, options, config, data);
}
export class HttpClient {
    constructor(app) {
        this.app = app;
        this.user = CREDENTIAL_USER.admin;
    }
    async send(req, apmTrackerName) {
        req.headers = Object.assign({}, req.headers);
        req.qs = Object.assign({}, req.qs);
        req.retry = req.retry || true;
        if (this.app !== undefined && req.service !== "external") {
            this.user = this.app.credential.getCurrentUser();
            req.headers[PROJECT_KEY_NAME] = this.app.config.projectKey;
            req.headers[ENVIRONMENT_KEY_NAME] = this.app.config.environment;
            req.headers[ENVIRONMENT] = this.app.config.environment;
            if (isNonEmptyString(process.env.X_ZOHO_CATALYST_ORG_ID)) {
                req.headers[X_ZOHO_CATALYST_ORG_ID] = process.env.X_ZOHO_CATALYST_ORG_ID;
            }
            if (isNonEmptyString(process.env.X_ZOHO_CATALYST_RESOURCE_ID)) {
                req.headers[X_ZOHO_CATALYST_RESOURCE_ID] = process.env
                    .X_ZOHO_CATALYST_RESOURCE_ID;
            }
            if (isNonEmptyString(this.app.config.projectSecretKey)) {
                req.headers[PROJECT_HEADER.projectSecretKey] = this.app.config
                    .projectSecretKey;
            }
            req.headers[USER_KEY_NAME] = this.app.credential.getCurrentUserType();
            if (IS_LOCAL === 'true') {
                switch (this.user) {
                    case CREDENTIAL_USER.admin:
                        req.origin =
                            'https://' +
                                CATALYST_ORIGIN.replace('https://', '').replace('http://', '');
                        break;
                    case CREDENTIAL_USER.user:
                        req.origin = 'https://' + this.app.config.projectDomain;
                        break;
                }
            }
            if (req.service === "baas") {
                req.headers[ACCEPT_HEADER.KEY] =
                    ACCEPT_HEADER.VALUE + ', ' + (req.headers[ACCEPT_HEADER.KEY] || '');
            }
            req.path =
                getServicePath(req.service) + `/project/${this.app.config.projectId}` + req.path;
        }
        try {
            let resp;
            if (req.track && apmTrackerName && IS_APM === 'true') {
                try {
                    const apminsight = await import('apminsight');
                    resp = await apminsight.startTracker(APM_INSIGHT.tracker_name, apmTrackerName, () => sendRequest(req));
                }
                catch (err) {
                    throw new CatalystAPIError('APM_TRACKER_ERROR', 'To enable APM tracking locally, please download the apminsight package from the UI and place it in the node_modules directory of your project.', err, 400);
                }
            }
            else {
                resp = await sendRequest(req);
            }
            return new DefaultHttpResponse(resp);
        }
        catch (err) {
            if (err instanceof Error) {
                throw new CatalystAPIError('REQUEST_FAILURE', err.message, err, err.message.includes('ECONNREFUSED') ? 503 : 400);
            }
            throw err;
        }
    }
}
export class AuthorizedHttpClient extends HttpClient {
    constructor(app, component) {
        super(app);
        if (component) {
            this.componentName = component.getComponentName();
        }
    }
    async send(request) {
        const requestCopy = Object.assign({ user: CREDENTIAL_USER.user }, request);
        requestCopy.headers = Object.assign({}, request.headers);
        if (request.auth !== false) {
            await this.app?.authenticateRequest(requestCopy);
        }
        return await super.send(requestCopy, this.componentName);
    }
}
