var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _a, _ResponseHandler_attachAppSpecificHeaders, _ResponseHandler_followZcrfTokenProtocol, _ResponseHandler_followJwtZCAuthProtocol, _ResponseHandler_sendRequest;
import { Auth_Protocol, ConfigManager, zcAuth } from '@zcatalyst/auth-client';
import { CONSTANTS, getServicePath, getToken } from '@zcatalyst/utils';
import { HTTP_HEADER_MAP as HEADER_MAP, HTTP_HEADER_MAP, X_ZCSRF_TOKEN, ZD_CSRPARAM } from './utils/constants';
import { CatalystAPIError } from './utils/errors';
import { requestTimeout } from './utils/request-timeout';
const { REQ_METHOD } = CONSTANTS;
export const keepAliveSupport = {
    supported: undefined
};
export class DefaultHttpResponse {
    constructor(resp) {
        this.statusCode = resp.statusCode;
        this.headers = resp.headers;
        this.config = resp.config;
        this.resp = resp;
    }
    get data() {
        if (this.resp.data === undefined) {
            throw new CatalystAPIError('UNPARSABLE_RESPONSE', `Error while processing response data. Raw server ` +
                `response: "${this.resp.data}". `, '', this.statusCode);
        }
        return this.resp.data;
    }
}
export class ResponseHandler {
    constructor() { }
    static async fireGeneralRequest({ requestCore, url }, requestOptions = {}) {
        try {
            const headers = requestCore.headers || {};
            const options = {
                method: requestCore.method,
                headers,
                credentials: requestOptions.auth ? 'include' : 'omit',
                body: requestCore.method !== REQ_METHOD.get ? requestCore.body : undefined
            };
            if (requestOptions.auth) {
                options.headers = await _a.attachZCAuthHeaders(headers);
                options.headers = __classPrivateFieldGet(this, _a, "m", _ResponseHandler_attachAppSpecificHeaders).call(this, headers);
            }
            const controller = new AbortController();
            if (requestOptions.abortSignal) {
                requestOptions.abortSignal.addEventListener('abort', () => controller.abort());
            }
            options.signal = controller.signal;
            const response = await Promise.race([
                fetch(url, options),
                requestTimeout(requestOptions?.requestTimeout)
            ]);
            if (!response.ok) {
                const errorData = await response.json().catch(() => null);
                throw new CatalystAPIError(`HTTP_ERROR_${response.status}`, errorData?.message || response.statusText, errorData, response.status);
            }
            if (requestOptions.retry && requestOptions.retry > 0) {
                try {
                    return await _a.wrapResponse(response, {
                        ...requestOptions,
                        request: requestCore
                    });
                }
                catch (error) {
                    requestOptions.retry--;
                    return this.fireGeneralRequest({ requestCore, url }, requestOptions);
                }
            }
            return await _a.wrapResponse(response, {
                ...requestOptions,
                request: requestCore
            });
        }
        catch (error) {
            if (error instanceof CatalystAPIError) {
                throw error;
            }
            if (error.name === 'AbortError') {
                throw new CatalystAPIError('REQUEST_ABORTED', 'The request was aborted', error);
            }
            if (error.name === 'TypeError' && error.message.includes('Failed to fetch')) {
                throw new CatalystAPIError('NETWORK_ERROR', 'Network error occurred while making the request', error);
            }
            throw new CatalystAPIError('REQUEST_FAILED', error.message || 'Request failed', error, error.statusCode);
        }
    }
    static async wrapResponse(response, options) {
        try {
            let data;
            switch (options?.expecting || "json") {
                case "buffer":
                    data = await response.arrayBuffer();
                    break;
                case "raw":
                    data = await response.blob();
                    break;
                case "json":
                    data = await response.json();
                    break;
                case "string":
                    data = await response.text();
                    break;
                default:
                    throw new CatalystAPIError('UNSUPPORTED_RESPONSE_TYPE', `Unsupported response type: ${options?.expecting}`);
            }
            return new DefaultHttpResponse({
                headers: response.headers,
                statusCode: response.status,
                data,
                request: options?.request || {},
                config: options || {}
            });
        }
        catch (error) {
            throw new CatalystAPIError('RESPONSE_PARSE_ERROR', 'Failed to parse response data', error);
        }
    }
    static async fireRawRequest(requestCore, reqOptions) {
        let headers = requestCore.headers;
        if (reqOptions.auth) {
            headers = await _a.attachZCAuthHeaders(headers);
            headers = __classPrivateFieldGet(this, _a, "m", _ResponseHandler_attachAppSpecificHeaders).call(this, headers);
            headers = { ...headers, credentials: 'include' };
        }
        const options = {
            method: requestCore.method,
            headers
        };
        if (requestCore.method !== REQ_METHOD.get && requestCore.body !== null)
            options.body = requestCore.body;
        const url = this.configManager.APIDomain
            ? `${this.configManager.APIDomain}${requestCore.url}`
            : requestCore.url;
        return await this.wrapResponse(await fetch(url, options));
    }
    static attachZCAuthHeaders(headers) {
        switch (this.configManager.AuthProtocol) {
            case Auth_Protocol.ZcrfTokenProtocol:
                return __classPrivateFieldGet(_a, _a, "m", _ResponseHandler_followZcrfTokenProtocol).call(_a, headers);
            case Auth_Protocol.JwtTokenProtocol:
                return __classPrivateFieldGet(_a, _a, "m", _ResponseHandler_followJwtZCAuthProtocol).call(_a, headers);
            default:
                return Promise.resolve(headers);
        }
    }
    static getJWTZCAuthToken() {
        const conf = ConfigManager.getInstance();
        return new Promise((resolve, reject) => {
            const jwtZCAuthToken = getToken();
            if (jwtZCAuthToken === '') {
                reject('Unable to get the JWT Access Token.');
            }
            else {
                resolve({
                    access_token: `${conf.jwtAuthTokenPrefix} ${jwtZCAuthToken}`
                });
            }
        });
    }
    static appendQueryString(url, qs) {
        if (!qs || Object.keys(qs).length === 0) {
            return url;
        }
        const searchParams = new URLSearchParams();
        Object.entries(qs)
            .filter(([_, value]) => value != null)
            .forEach(([key, value]) => searchParams.append(key, String(value)));
        const baseUrl = url.split('?')[0];
        const existingParams = url.split('?')[1] || '';
        return `${baseUrl}?${existingParams ? `${existingParams}&` : ''}${searchParams.toString()}`;
    }
    static async send(options) {
        const headers = options.headers || {};
        let data = options.data;
        if (data !== undefined) {
            switch (options.type) {
                case "json":
                    data = JSON.stringify(data);
                    headers['Content-Type'] = HEADER_MAP.CONTENT_JSON;
                    break;
                case "file":
                    const formData = new FormData();
                    const keyData = Object.keys(data);
                    keyData.forEach((key) => {
                        formData.append(key, data[key]);
                    });
                    data = formData;
                    break;
                case "raw":
                    data = JSON.stringify(data);
                    if (headers['Content-Type'] === undefined) {
                        headers['Content-Type'] = 'application/octet-stream';
                    }
                    break;
                default:
                    data = JSON.stringify(data);
                    headers['Content-Type'] = 'application/x-www-form-urlencoded';
                    headers['Content-Length'] = Buffer.byteLength(data) + '';
            }
        }
        if (this.configManager.APIDomain === null && !options.origin) {
            throw new CatalystAPIError('API_REQUEST_ERROR', 'Unable to get the base url');
        }
        if (options.service !== "external" && options.path) {
            options.path = `${getServicePath(options.service)}/project/${this.configManager.ProjectID}${options.path}`;
        }
        const request = {
            url: options.url ?? `${options.origin ?? this.configManager.APIDomain}${options.path}`,
            method: options.method,
            ...(data ? { body: data } : {}),
            headers
        };
        request.url = this.appendQueryString(request.url, options.qs);
        return await __classPrivateFieldGet(this, _a, "m", _ResponseHandler_sendRequest).call(this, request, {
            expecting: options.expecting,
            auth: options.auth ?? true
        });
    }
}
_a = ResponseHandler, _ResponseHandler_attachAppSpecificHeaders = function _ResponseHandler_attachAppSpecificHeaders(headers) {
    const normalizedHeaders = headers;
    const currentAccept = normalizedHeaders['Accept'];
    if (!currentAccept) {
        normalizedHeaders['Accept'] = 'application/vnd.catalyst.v2+json';
    }
    else {
        normalizedHeaders['Accept'] = `application/vnd.catalyst.v2+json, ${currentAccept}`;
    }
    if (typeof this.configManager?.OrgId === 'string') {
        normalizedHeaders['CATALYST-ORG'] = this.configManager.OrgId;
    }
    normalizedHeaders['CATALYST-COMPONENT'] = 'true';
    return normalizedHeaders;
}, _ResponseHandler_followZcrfTokenProtocol = async function _ResponseHandler_followZcrfTokenProtocol(headers) {
    return zcAuth
        .collectZCRFToken()
        .then(() => {
        headers[X_ZCSRF_TOKEN] =
            `${ZD_CSRPARAM}=${this.configManager.CsrfToken}`;
        return headers;
    })
        .catch((err) => {
        throw new CatalystAPIError('API_ERROR', err.message, err.status);
    });
}, _ResponseHandler_followJwtZCAuthProtocol = async function _ResponseHandler_followJwtZCAuthProtocol(headers) {
    return this.getJWTZCAuthToken()
        .then((resp) => {
        headers[HTTP_HEADER_MAP.AUTHORIZATION_KEY] =
            resp.access_token;
        return headers;
    })
        .catch((err) => {
        throw new CatalystAPIError('API_ERROR', err.message, err.status);
    });
}, _ResponseHandler_sendRequest = async function _ResponseHandler_sendRequest(request, options) {
    const { url, ...requestCore } = request;
    return _a.fireGeneralRequest({ url, requestCore }, options);
};
ResponseHandler.configManager = ConfigManager.getInstance();
