'use strict';
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.AuthorizedHttpClient = exports.HttpClient = exports.DefaultHttpResponse = void 0;
const utils_1 = require("@zcatalyst/utils");
const http_1 = __importDefault(require("http"));
const https_1 = __importDefault(require("https"));
const web_1 = require("node:stream/web");
const querystring_1 = require("querystring");
const stream_1 = require("stream");
const url_1 = require("url");
const util_1 = require("util");
const package_json_1 = require("../package.json");
const errors_1 = require("./utils/errors");
const form_data_1 = __importDefault(require("./utils/form-data"));
const helpers_1 = require("./utils/helpers");
const request_agent_1 = __importDefault(require("./utils/request-agent"));
const { PROJECT_KEY_NAME, IS_LOCAL, ENVIRONMENT_KEY_NAME, ENVIRONMENT, USER_KEY_NAME, CREDENTIAL_USER, CATALYST_ORIGIN, X_ZOHO_CATALYST_ORG_ID, USER_AGENT, APM_INSIGHT, ACCEPT_HEADER, REQ_RETRY_THRESHOLD, PROJECT_HEADER, IS_APM, X_ZOHO_CATALYST_RESOURCE_ID } = utils_1.CONSTANTS;
class DefaultHttpResponse {
    constructor(resp) {
        this.statusCode = resp.statusCode;
        this.headers = resp.headers;
        this.config = resp.config;
        this.resp = resp;
    }
    get data() {
        switch (this.config.expecting) {
            case "string":
                if (this.resp.data === undefined) {
                    throw new errors_1.CatalystAPIError('UNPARSABLE_RESPONSE', `Error while processing response data. Raw server ` +
                        `response: "${this.resp.data}". Status code: "${this.statusCode}".`, '', this.statusCode);
                }
                return this.resp.data;
            case "buffer":
                if (this.resp.buffer === undefined) {
                    throw new errors_1.CatalystAPIError('UNPARSABLE_RESPONSE', `Error while processing response buffer. Raw server ` +
                        `response: "${this.resp.data}". Status code: "${this.statusCode}".`, '', this.statusCode);
                }
                return this.resp.buffer;
            case "raw":
                return this.resp.stream;
            default:
                try {
                    return JSON.parse(this.resp.data);
                }
                catch (e) {
                    throw new errors_1.CatalystAPIError('UNPARSABLE_RESPONSE', `Error while parsing response data: "${(0, util_1.inspect)(e)}". Raw server ` +
                        `response: "${this.resp.data}". Status code: "${this.statusCode}".`, '', this.statusCode);
                }
        }
    }
}
exports.DefaultHttpResponse = DefaultHttpResponse;
function rejectWithContext(reject, statusCode, data) {
    try {
        const catalystError = JSON.parse(data);
        reject({
            statusCode,
            code: catalystError.data.error_code,
            message: catalystError.data.message
        });
        return;
    }
    catch (err) {
        reject({
            statusCode,
            message: (0, util_1.inspect)(data)
        });
    }
}
async function streamToBuffer(stream) {
    const chunks = [];
    return new Promise((resolve, reject) => {
        stream.destroyed && reject('Invalid response stream');
        stream.on('data', (chunk) => {
            chunks.push(chunk);
        });
        stream.on('error', reject);
        stream.on('end', () => resolve(Buffer.concat(chunks)));
    });
}
function constructFormData(data) {
    const formData = new form_data_1.default();
    const keyData = Object.keys(data);
    keyData.forEach((key) => {
        formData.append(key, data[key]);
    });
    return formData;
}
async function _finalizeRequest(resolve, reject, response) {
    if (response.statusCode === undefined) {
        reject(new errors_1.CatalystAPIError('UNKNOWN_STATUSCODE', 'unable to obtain status code from response', response));
        return;
    }
    if (response.statusCode >= 200 && response.statusCode < 300) {
        resolve(response);
        return;
    }
    if (response.stream?.pipe === undefined) {
        rejectWithContext(reject, response.statusCode, response.data);
        return;
    }
    try {
        if (response.stream !== undefined && response.data === undefined) {
            const responseBuffer = await streamToBuffer(response.stream);
            response.data = responseBuffer.toString();
        }
        if (response.statusCode === 404) {
            rejectWithContext(reject, response.statusCode, response.data || 'Not Found');
        }
        else if (response.statusCode === 403) {
            rejectWithContext(reject, response.statusCode, response.data || 'Access Denied');
        }
        else if (response.statusCode === 401) {
            rejectWithContext(reject, response.statusCode, response.data || 'Unauthorized');
        }
        else {
            rejectWithContext(reject, response.statusCode, response.data || 'Unknown response');
        }
    }
    catch (e) {
        const errMsg = e instanceof Error ? e.message : (0, util_1.inspect)(e);
        rejectWithContext(reject, response.statusCode, errMsg);
    }
}
function _appendQueryData(url, data) {
    if (data && Object.keys(data).length > 0) {
        url += url.includes('?') ? '&' : '?';
        url += (0, querystring_1.stringify)(data);
    }
    return url;
}
async function _request(transport, options, config, data, retryCount = 0) {
    const clonedData = data === undefined
        ? undefined
        : config.type !== "file"
            ?
                data
            :
                data.createClone();
    return new Promise(async (resolve, reject) => {
        const retryRequest = async (err) => {
            utils_1.LOGGER.warn('>>> RETRYING REQUEST ');
            if (retryCount++ === REQ_RETRY_THRESHOLD) {
                reject(err);
                return;
            }
            try {
                options.agent = new request_agent_1.default((0, helpers_1.isHttps)(config.url), options.hostname, true).agent;
                const resp = await _request(transport, options, config, clonedData, retryCount);
                resolve(resp);
            }
            catch (e) {
                reject(e);
            }
        };
        const startTimeStamp = Date.now();
        const req = transport.request(options, async (res) => {
            if (req.destroyed) {
                return;
            }
            const response = {
                headers: res.headers,
                request: req,
                stream: res,
                statusCode: res.statusCode,
                config
            };
            utils_1.LOGGER.debug(`>>> HTTP REQUEST : ${req.method?.toUpperCase()} ${req.protocol}//${req.host}${req.path}`);
            process.env.ZC_SECURE?.toLowerCase() === 'override' &&
                utils_1.LOGGER.fine(`>>> REQUEST HEADERS : ${JSON.stringify(options.headers)}`);
            utils_1.LOGGER.debug(`<<< HTTP RESPONSE : ${res.statusCode} : ${Date.now() - startTimeStamp} ms`);
            process.env.ZC_SECURE?.toLowerCase() === 'override' &&
                utils_1.LOGGER.fine(`<<< RESPONSE HEADERS : ${JSON.stringify(res.headers)}`);
            if (config.expecting === "raw") {
                return _finalizeRequest(resolve, reject, response);
            }
            try {
                const responseBuffer = await streamToBuffer(res);
                response.data = responseBuffer.toString();
                response.buffer = responseBuffer;
            }
            catch (err) {
                if (req.destroyed || (config.abortSignal && config.abortSignal.aborted)) {
                    req.destroy();
                    return;
                }
                reject(err);
            }
            _finalizeRequest(resolve, reject, response);
        });
        req.on('error', (err) => {
            utils_1.LOGGER.debug(`>>> HTTP REQUEST : ${req.method?.toUpperCase()} ${req.protocol}//${req.host}${req.path}`);
            process.env.ZC_SECURE?.toLowerCase() === 'override' &&
                utils_1.LOGGER.fine(`>>> REQUEST HEADERS : ${JSON.stringify(options.headers)}`);
            utils_1.LOGGER.debug(`<<< HTTP REQUEST ERROR : ${(0, util_1.inspect)(err)} : ${Date.now() - startTimeStamp} ms`);
            if (req.destroyed || config.type === "raw") {
                return reject(err);
            }
            retryRequest(err);
        });
        if (data === undefined) {
            req.end();
            return;
        }
        if (config.type !== "file" && config.type !== "raw") {
            req.write(data);
            req.end();
            return;
        }
        if (data instanceof web_1.ReadableStream) {
            data = webStreamToNodeStream(data);
        }
        data.on('error', (er) => {
            reject(er);
            req.end();
        });
        data.pipe(req).on('finish', req.end);
    });
}
function webStreamToNodeStream(webStream) {
    const reader = webStream.getReader();
    return new stream_1.Readable({
        async read() {
            const { done, value } = await reader.read();
            if (done) {
                this.push(null);
            }
            else {
                this.push(value);
            }
        }
    });
}
async function sendRequest(config) {
    let data;
    let headers = Object.assign({
        [USER_AGENT.KEY]: USER_AGENT.PREFIX + package_json_1.version
    }, config.headers);
    if (config.data !== undefined) {
        switch (config.type) {
            case "json":
                data = JSON.stringify(config.data);
                headers['Content-Type'] = 'application/json';
                break;
            case "file":
                data = constructFormData(config.data);
                headers = data.getHeaders(headers);
                break;
            case "raw":
                data = config.data;
                if (headers['Content-Type'] === undefined) {
                    headers['Content-Type'] = 'application/octet-stream';
                }
                break;
            default:
                data = (0, querystring_1.stringify)(config.data);
                headers['Content-Type'] = 'application/x-www-form-urlencoded';
                headers['Content-Length'] = Buffer.byteLength(data) + '';
        }
    }
    const origin = config.origin || CATALYST_ORIGIN;
    config.url = config.url || new url_1.URL(config.path || '', origin).href;
    if (config.qs !== undefined) {
        config.url = _appendQueryData(config.url, config.qs);
    }
    const parsedUrl = new url_1.URL(config.url);
    if (parsedUrl.hostname === null) {
        throw new errors_1.CatalystAPIError('UNPARSABLE_CONFIG', 'Hostname cannot be null', config.path, 400);
    }
    const isHttpsProtocol = (0, helpers_1.isHttps)(parsedUrl);
    const requestAgent = new request_agent_1.default(isHttpsProtocol, parsedUrl.hostname, false);
    parsedUrl.searchParams?.sort();
    const options = {
        hostname: parsedUrl.hostname,
        port: parsedUrl.port,
        path: parsedUrl.pathname + parsedUrl.search,
        method: config.method,
        headers,
        agent: requestAgent.agent
    };
    const transport = isHttpsProtocol ? https_1.default : http_1.default;
    return _request(transport, options, config, data);
}
class HttpClient {
    constructor(app) {
        this.app = app;
        this.user = CREDENTIAL_USER.admin;
    }
    async send(req, apmTrackerName) {
        req.headers = Object.assign({}, req.headers);
        req.qs = Object.assign({}, req.qs);
        req.retry = req.retry || true;
        if (this.app !== undefined && req.service !== "external") {
            this.user = this.app.credential.getCurrentUser();
            req.headers[PROJECT_KEY_NAME] = this.app.config.projectKey;
            req.headers[ENVIRONMENT_KEY_NAME] = this.app.config.environment;
            req.headers[ENVIRONMENT] = this.app.config.environment;
            if ((0, utils_1.isNonEmptyString)(process.env.X_ZOHO_CATALYST_ORG_ID)) {
                req.headers[X_ZOHO_CATALYST_ORG_ID] = process.env.X_ZOHO_CATALYST_ORG_ID;
            }
            if ((0, utils_1.isNonEmptyString)(process.env.X_ZOHO_CATALYST_RESOURCE_ID)) {
                req.headers[X_ZOHO_CATALYST_RESOURCE_ID] = process.env
                    .X_ZOHO_CATALYST_RESOURCE_ID;
            }
            if ((0, utils_1.isNonEmptyString)(this.app.config.projectSecretKey)) {
                req.headers[PROJECT_HEADER.projectSecretKey] = this.app.config
                    .projectSecretKey;
            }
            req.headers[USER_KEY_NAME] = this.app.credential.getCurrentUserType();
            if (IS_LOCAL === 'true') {
                switch (this.user) {
                    case CREDENTIAL_USER.admin:
                        req.origin =
                            'https://' +
                                CATALYST_ORIGIN.replace('https://', '').replace('http://', '');
                        break;
                    case CREDENTIAL_USER.user:
                        req.origin = 'https://' + this.app.config.projectDomain;
                        break;
                }
            }
            if (req.service === "baas") {
                req.headers[ACCEPT_HEADER.KEY] =
                    ACCEPT_HEADER.VALUE + ', ' + (req.headers[ACCEPT_HEADER.KEY] || '');
            }
            req.path =
                (0, utils_1.getServicePath)(req.service) + `/project/${this.app.config.projectId}` + req.path;
        }
        try {
            let resp;
            if (req.track && apmTrackerName && IS_APM === 'true') {
                try {
                    const apminsight = await Promise.resolve().then(() => __importStar(require('apminsight')));
                    resp = await apminsight.startTracker(APM_INSIGHT.tracker_name, apmTrackerName, () => sendRequest(req));
                }
                catch (err) {
                    throw new errors_1.CatalystAPIError('APM_TRACKER_ERROR', 'To enable APM tracking locally, please download the apminsight package from the UI and place it in the node_modules directory of your project.', err, 400);
                }
            }
            else {
                resp = await sendRequest(req);
            }
            return new DefaultHttpResponse(resp);
        }
        catch (err) {
            if (err instanceof Error) {
                throw new errors_1.CatalystAPIError('REQUEST_FAILURE', err.message, err, err.message.includes('ECONNREFUSED') ? 503 : 400);
            }
            throw err;
        }
    }
}
exports.HttpClient = HttpClient;
class AuthorizedHttpClient extends HttpClient {
    constructor(app, component) {
        super(app);
        if (component) {
            this.componentName = component.getComponentName();
        }
    }
    async send(request) {
        const requestCopy = Object.assign({ user: CREDENTIAL_USER.user }, request);
        requestCopy.headers = Object.assign({}, request.headers);
        if (request.auth !== false) {
            await this.app?.authenticateRequest(requestCopy);
        }
        return await super.send(requestCopy, this.componentName);
    }
}
exports.AuthorizedHttpClient = AuthorizedHttpClient;
