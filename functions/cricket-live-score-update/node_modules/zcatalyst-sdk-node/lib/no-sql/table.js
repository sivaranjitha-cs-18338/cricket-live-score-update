"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
var _NoSQLTable_tableDetails, _NoSQLTable_requester, _NoSQLTable_tableId;
Object.defineProperty(exports, "__esModule", { value: true });
const constants_1 = __importDefault(require("../utils/constants"));
const validator_1 = require("../utils/validator");
const error_1 = require("../utils/error");
const enum_1 = require("./enum");
const response_1 = __importDefault(require("./response"));
const { COMPONENT, REQ_METHOD, CREDENTIAL_USER } = constants_1.default;
class NoSQLTable {
    constructor(requester, { tableDetails, tableId }) {
        _NoSQLTable_tableDetails.set(this, void 0);
        _NoSQLTable_requester.set(this, void 0);
        _NoSQLTable_tableId.set(this, void 0);
        __classPrivateFieldSet(this, _NoSQLTable_requester, requester, "f");
        __classPrivateFieldSet(this, _NoSQLTable_tableDetails, tableDetails, "f");
        __classPrivateFieldSet(this, _NoSQLTable_tableId, tableId || (tableDetails === null || tableDetails === void 0 ? void 0 : tableDetails.id) || (tableDetails === null || tableDetails === void 0 ? void 0 : tableDetails.name), "f");
    }
    /**
     * Insert items to the table
     * @param values values to be inserted
     * @returns NoSQL Response with create response
     *
     * @example
     * ```js
     * const { NoSQLItem } = require('zcatalyst-sdk/lib/no-sql');
     * const insertedItems = await table.insertItems({
     *		// item to be inserted
     *		item: NoSQLItem.from({ part_key: "a" }),
     *	});
     * ```
     */
    insertItems(...values) {
        return __awaiter(this, void 0, void 0, function* () {
            yield (0, validator_1.wrapValidatorsWithPromise)(() => {
                (0, validator_1.isNonEmptyArray)(values, 'values', true);
            }, error_1.CatalystNoSQLError);
            const request = {
                method: REQ_METHOD.post,
                path: `/nosqltable/${__classPrivateFieldGet(this, _NoSQLTable_tableId, "f")}/item`,
                data: values,
                type: "json" /* RequestType.JSON */,
                catalyst: true,
                track: true,
                user: CREDENTIAL_USER.admin
            };
            const resp = yield __classPrivateFieldGet(this, _NoSQLTable_requester, "f").send(request);
            const _resp = resp.data.data;
            _resp.operation = enum_1.NoSQLCrudOperation.CREATE;
            return new response_1.default(_resp);
        });
    }
    /**
     * Update items in table
     * @param values items to be updated
     * @returns NoSQL Update with update response
     *
     * @example
     * ```js
     * const { NoSQLMarshall, NoSQLEnum } = require('zcatalyst-sdk/lib/no-sql');
     * const { NoSQLUpdateOperationType } = NoSQLEnum;
     * // {
     * // 	'part_key': 'a',
     * // 	'info': null, <== update the { new_val: 'xyz' } value here
     * // }
     * const updatedItems = await table.updateItems({
     * 	// partition key of the item to be updated
     * 	keys: new NoSQLItem().addString('part_key', 'a'),
     * 	// attributes to be updated
     * 	update_attributes: [
     * 		{
     * 			// type of update operation
     * 			operation_type: NoSQLUpdateOperationType.PUT,
     * 			// value of the attribute to be updated
     * 			update_value: NoSQLMarshall.make({ new_val: 'xyz' }),
     * 			// path to the attribute
     * 			attribute_path: ['info']
     * 		}
     * 	]
     * });
     * ```
     */
    updateItems(...values) {
        return __awaiter(this, void 0, void 0, function* () {
            yield (0, validator_1.wrapValidatorsWithPromise)(() => {
                (0, validator_1.isNonEmptyArray)(values, 'values', true);
            }, error_1.CatalystNoSQLError);
            const request = {
                method: REQ_METHOD.put,
                path: `/nosqltable/${__classPrivateFieldGet(this, _NoSQLTable_tableId, "f")}/item`,
                data: values,
                type: "json" /* RequestType.JSON */,
                catalyst: true,
                track: true,
                user: CREDENTIAL_USER.admin
            };
            const resp = yield __classPrivateFieldGet(this, _NoSQLTable_requester, "f").send(request);
            const _resp = resp.data.data;
            _resp.operation = enum_1.NoSQLCrudOperation.UPDATE;
            return new response_1.default(_resp);
        });
    }
    /**
     * Delete items from the table
     * @param values item to be deleted
     * @returns NoSQL Response with delete response
     *
     * @example
     * ```js
     * const { NoSQLItem } = require('zcatalyst-sdk/lib/no-sql');
     * const deletedItem = await table.deleteItems({
     *		// partition key of the item to be deleted
     *		keys: NoSQLItem.from({ fruit: 'apple' })
     *	});
     * ```
     */
    deleteItems(...values) {
        return __awaiter(this, void 0, void 0, function* () {
            yield (0, validator_1.wrapValidatorsWithPromise)(() => {
                (0, validator_1.isNonEmptyArray)(values, 'values', true);
            }, error_1.CatalystNoSQLError);
            const request = {
                method: REQ_METHOD.delete,
                path: `/nosqltable/${__classPrivateFieldGet(this, _NoSQLTable_tableId, "f")}/item`,
                data: values,
                headers: {
                    'Content-Length': JSON.stringify(values).length.toString() // temp handling for delete method body
                },
                type: "json" /* RequestType.JSON */,
                catalyst: true,
                track: true,
                user: CREDENTIAL_USER.admin
            };
            const resp = yield __classPrivateFieldGet(this, _NoSQLTable_requester, "f").send(request);
            const _resp = resp.data.data;
            _resp.operation = enum_1.NoSQLCrudOperation.DELETE;
            return new response_1.default(_resp);
        });
    }
    /**
     * Fetch items from the table
     * @param value item to be fetched
     * @returns NoSQL Response with read response
     *
     * @example
     * const { NoSQLItem } = require('zcatalyst-sdk/lib/no-sql');
     * const fetchedItem = await table.fetchItem({
     * 		// partition key of the item to be fetched
     * 		keys: [new NoSQLItem().addString('part_key', 'a')],
     * 		// is consistent read enabled
     * 		consistent_read: true,
     * 		// attributes to be fetched
     * 		required_attributes: [['info', 'new_value']]
     * });
     */
    fetchItem(value) {
        return __awaiter(this, void 0, void 0, function* () {
            yield (0, validator_1.wrapValidatorsWithPromise)(() => {
                (0, validator_1.isNonEmptyObject)(value, 'value', true);
            }, error_1.CatalystNoSQLError);
            if (!Array.isArray(value.keys)) {
                value.keys = [value.keys];
            }
            const request = {
                method: REQ_METHOD.post,
                path: `/nosqltable/${__classPrivateFieldGet(this, _NoSQLTable_tableId, "f")}/item/fetch`,
                data: value,
                type: "json" /* RequestType.JSON */,
                catalyst: true,
                track: true,
                user: CREDENTIAL_USER.admin
            };
            const resp = yield __classPrivateFieldGet(this, _NoSQLTable_requester, "f").send(request);
            const _resp = resp.data.data;
            _resp.operation = enum_1.NoSQLCrudOperation.READ;
            return new response_1.default(_resp);
        });
    }
    /**
     * Query items from the table
     * @param query query to be executed
     * @returns NoSQL Response with read response
     *
     * @example
     * ```js
     * const { NoSQLEnum, NoSQLMarshall } = require('zcatalyst-sdk/lib/no-sql');
     * const { NoSQLOperator } = NoSQLEnum;
     * const queriedItem = await table.queryTable({
     *		// condition to identify the item
     *		key_condition: {
     *			// NoSQL attribute path
     *			attribute: ['info', 'new_value'],
     *			// NoSQL operator
     *			operator: NoSQLOperator.EQUALS,
     *			// Value for comparison
     *			value: NoSQLMarshall.makeString('xyz')
     *		}
     *	});
     * ```
     *
     */
    queryTable(query) {
        return __awaiter(this, void 0, void 0, function* () {
            yield (0, validator_1.wrapValidatorsWithPromise)(() => {
                (0, validator_1.isNonEmptyObject)(query, 'query', true);
            }, error_1.CatalystNoSQLError);
            const request = {
                method: REQ_METHOD.post,
                path: `/nosqltable/${__classPrivateFieldGet(this, _NoSQLTable_tableId, "f")}/item/query`,
                data: query,
                type: "json" /* RequestType.JSON */,
                catalyst: true,
                track: true,
                user: CREDENTIAL_USER.admin
            };
            const resp = yield __classPrivateFieldGet(this, _NoSQLTable_requester, "f").send(request);
            const _resp = resp.data.data;
            _resp.operation = enum_1.NoSQLCrudOperation.READ;
            return new response_1.default(_resp);
        });
    }
    /**
     * Query indexes of the table
     * @param indexId Id or Name of the NoSQL table index
     * @param query NoSQL Query to be executed
     * @returns NoSQL Response with read response
     *
     * @example
     * ```js
     * const { NoSQLEnum, NoSQLMarshall } = require('zcatalyst-sdk/lib/no-sql');
     * const { NoSQLOperator } = NoSQLEnum;
     * // mention the index to be queried
     * const queriedIndexItems = await table.queryIndex('test-idx', {
     *		// condition to identify the item
     *		key_condition: {
     *			// NoSQL attribute path
     *			attribute: ['info', 'new_value'],
     *			// NoSQL operator
     *			operator: NoSQLOperator.EQUALS,
     *			// Value for comparison
     *			value: NoSQLMarshall.makeString('xyz')
     *		}
     *	});
     * ```
     */
    queryIndex(indexId, query) {
        return __awaiter(this, void 0, void 0, function* () {
            yield (0, validator_1.wrapValidatorsWithPromise)(() => {
                (0, validator_1.isNonEmptyString)(indexId, 'indexId', true);
                (0, validator_1.isNonEmptyObject)(query, 'query', true);
            }, error_1.CatalystNoSQLError);
            const request = {
                method: REQ_METHOD.post,
                path: `/nosqltable/${__classPrivateFieldGet(this, _NoSQLTable_tableId, "f")}/index/${indexId}/item/query`,
                data: query,
                type: "json" /* RequestType.JSON */,
                catalyst: true,
                track: true,
                user: CREDENTIAL_USER.admin
            };
            const resp = yield __classPrivateFieldGet(this, _NoSQLTable_requester, "f").send(request);
            const _resp = resp.data.data;
            _resp.operation = enum_1.NoSQLCrudOperation.READ;
            return new response_1.default(_resp);
        });
    }
    /**
     *
     * @throws **CatalystNoSQLError** with code `no_data` if the table details are not present
     */
    toString() {
        if (!__classPrivateFieldGet(this, _NoSQLTable_tableDetails, "f")) {
            throw new error_1.CatalystNoSQLError('no_data', 'this NoSQLTable object does not contain table data');
        }
        return JSON.stringify(__classPrivateFieldGet(this, _NoSQLTable_tableDetails, "f"));
    }
    /**
     * Get a json representation of the NoSQL table's details
     * @throws **CatalystNoSQLError** with code `no_data` if the table details are not present
     */
    toJSON() {
        if (!__classPrivateFieldGet(this, _NoSQLTable_tableDetails, "f")) {
            throw new error_1.CatalystNoSQLError('no_data', 'this NoSQLTable object does not contain table data');
        }
        return __classPrivateFieldGet(this, _NoSQLTable_tableDetails, "f");
    }
    getComponentName() {
        return COMPONENT.no_sql;
    }
}
exports.default = NoSQLTable;
_NoSQLTable_tableDetails = new WeakMap(), _NoSQLTable_requester = new WeakMap(), _NoSQLTable_tableId = new WeakMap();
