"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.NoSQLMarshall = void 0;
const error_1 = require("../utils/error");
const byte_1 = require("./byte");
const enum_1 = require("./enum");
const set_1 = require("./set");
/**
 * Class that contains the marshalling utils.
 * Converts native or near-native js object to NoSQL attributes
 */
class NoSQLMarshall {
    /**
     * Make a NoSQL null attribute
     * @returns NoSQL null(NULL) attribute
     */
    static makeNull() {
        return {
            [enum_1.DataType.NULL]: true
        };
    }
    /**
     * Make a NoSQL string attribute from string value
     * @param value string value
     * @returns NoSQL string(S) attribute
     */
    static makeString(value) {
        return {
            [enum_1.DataType.S]: value
        };
    }
    /**
     * Make a NoSQL number attribute from number or bigint values
     * @param value number or bigint value
     * @returns NoSQL number(N) attribute
     */
    static makeNumber(value) {
        if ([Number.NaN, Number.POSITIVE_INFINITY, Number.NEGATIVE_INFINITY]
            .map((val) => val.toString())
            .includes(value.toString())) {
            throw new error_1.CatalystNoSQLError('invalid_number', `Invalid number value ${value.toString()}`);
        }
        else if (value > Number.MAX_SAFE_INTEGER) {
            throw new error_1.CatalystNoSQLError('unsafe_number', `Number ${value.toString()} is greater than Number.MAX_SAFE_INTEGER. Use BigInt`);
        }
        else if (value < Number.MIN_SAFE_INTEGER) {
            throw new error_1.CatalystNoSQLError('unsafe_number', `Number ${value.toString()} is lesser than Number.MIN_SAFE_INTEGER. Use BigInt`);
        }
        return { N: value.toString() };
    }
    /**
     * Make a NoSQL byte attribute
     * @param value base64 encoded string or NoSQLByte or array buffers listed in TNoSQLByte type
     * @returns NoSQL byte attribute
     */
    static makeByte(value) {
        return {
            [enum_1.DataType.B]: value instanceof byte_1.NoSQLByte ? value : new byte_1.NoSQLByte(value)
        };
    }
    /**
     * Make a NoSQL boolean attribute
     * @param value boolean value
     * @returns NoSQL boolean (BOOL) attribute
     */
    static makeBoolean(value) {
        return {
            [enum_1.DataType.BOOL]: value === true ? 'true' : 'false'
        };
    }
    /**
     * Make a NoSQL list attribute from an Array
     * @param value Array of NoSQL compatible data types
     * @returns NoSQL list(L) attribute
     */
    static makeList(value) {
        return {
            [enum_1.DataType.L]: value.map((val) => {
                return this.make(val);
            })
        };
    }
    /**
     * Make a NoSQL map attribute from an object
     * @param value object
     * @param options marshalling options
     * @returns NoSQL Map(M) attribute
     */
    static makeMap(value, options) {
        const map = {};
        if (value instanceof Map) {
            for (const [key, val] of value) {
                if (typeof val !== 'function' &&
                    (value !== undefined || !(options === null || options === void 0 ? void 0 : options.removeUndefinedValues))) {
                    map[key] = this.make(val, options);
                }
            }
        }
        Object.entries(value).forEach(([key, val]) => {
            if (typeof val !== 'function' &&
                (value !== undefined || !(options === null || options === void 0 ? void 0 : options.removeUndefinedValues))) {
                map[key] = this.make(val, options);
            }
        });
        return {
            [enum_1.DataType.M]: map
        };
    }
    /**
     * Make a NoSQL string set attribute from a set of strings or NoSQLStringSet
     * @param value Set of strings or NoSQLStringSet value
     * @returns NoSQL string set(SS) attribute
     */
    static makeStringSet(value) {
        return {
            [enum_1.DataType.SS]: value instanceof set_1.NoSQLStringSet ? value : new set_1.NoSQLStringSet([...value])
        };
    }
    /**
     * Make a NoSQL number set attribute from a set of number or bigint or NoSQLNumberSet
     * @param value Set of number or bigint or NoSQLNumberSet value
     * @returns NoSQL number set(SN) attribute
     */
    static makeNumberSet(value) {
        return {
            [enum_1.DataType.SN]: value instanceof set_1.NoSQLNumberSet ? value : new set_1.NoSQLNumberSet([...value])
        };
    }
    /**
     * Make a NoSQL byte set attribute from a set of byte or base64 encoded string or NoSQLByteSet
     * @param value Set of byte or base64 encoded string or NoSQLByteSet value
     * @returns NoSQL byte set(SB) attribute
     */
    static makeByteSet(value) {
        return {
            [enum_1.DataType.SB]: value instanceof set_1.NoSQLByteSet ? value : new set_1.NoSQLByteSet([...value])
        };
    }
    /**
     * Make NoSQL set attribute from set
     * @param set set to be converted
     * @param options options to be used when marshalling
     * @returns NoSQL set attribute (SS, SN, SB)
     */
    static makeSet(set, options) {
        const setToOperate = (options === null || options === void 0 ? void 0 : options.removeUndefinedValues)
            ? new Set([...set].filter((value) => value !== undefined))
            : set;
        if (!(options === null || options === void 0 ? void 0 : options.removeUndefinedValues) && setToOperate.has(undefined)) {
            throw new Error('Set cannot contain "undefined" value. Pass options.removeUndefinedValues=true to remove undefined values from map/list/set.');
        }
        if (setToOperate.size === 0) {
            if (options === null || options === void 0 ? void 0 : options.convertEmptyValues) {
                return this.makeNull();
            }
            throw new Error('Pass a non-empty set, or options.convertEmptyValues=true.');
        }
        const item = setToOperate.values().next().value;
        if (typeof item === 'number' || typeof item === 'bigint') {
            return this.makeNumberSet(set);
        }
        else if (typeof item === 'string') {
            return this.makeStringSet(set);
        }
        else if (byte_1.NoSQLByte.isBuffer(item)) {
            return this.makeByteSet(set);
        }
        else {
            throw new Error(`Only Number Set (SN), Binary Set (SB) or String Set (SS) are allowed.`);
        }
    }
    /**
     * Make a NoSQL attribute from native js values
     * @param data value to be converted to NoSQL attribute
     * @param options options to be used when converting js values to NoSQL attributes
     * @returns NoSQL attribute
     */
    static make(data, options) {
        var _a, _b;
        if (data === undefined) {
            throw new Error(`Pass options.removeUndefinedValues=true to remove undefined values from map/array/set.`);
        }
        else if (data === null && typeof data === 'object') {
            return this.makeNull();
        }
        else if (Array.isArray(data)) {
            return this.makeList(data);
        }
        else if (data instanceof Set) {
            return this.makeSet(data, options);
        }
        else if (((_a = data === null || data === void 0 ? void 0 : data.constructor) === null || _a === void 0 ? void 0 : _a.name) === 'Map') {
            return this.makeMap(data, options);
        }
        else if (((_b = data === null || data === void 0 ? void 0 : data.constructor) === null || _b === void 0 ? void 0 : _b.name) === 'Object' ||
            // for object which is result of Object.create(null), which doesn't have constructor defined
            (!data.constructor && typeof data === 'object')) {
            return this.makeMap(data, options);
        }
        else if (byte_1.NoSQLByte.isBuffer(data)) {
            if (data.length === 0 && (options === null || options === void 0 ? void 0 : options.convertEmptyValues)) {
                return this.makeNull();
            }
            return this.makeByte(data);
        }
        else if (typeof data === 'boolean') {
            return this.makeBoolean(data);
        }
        else if (typeof data === 'number') {
            return this.makeNumber(data);
        }
        else if (typeof data === 'bigint') {
            return this.makeNumber(data);
        }
        else if (typeof data === 'string') {
            if (data.length === 0 && (options === null || options === void 0 ? void 0 : options.convertEmptyValues)) {
                return this.makeNull();
            }
            return this.makeString(data);
        }
        else if ((options === null || options === void 0 ? void 0 : options.convertClassInstanceToMap) && typeof data === 'object') {
            return this.makeMap(data, options);
        }
        throw new Error(`Unsupported type passed. Pass options.convertClassInstanceToMap=true to marshall typeof object as map attribute.`);
    }
}
exports.NoSQLMarshall = NoSQLMarshall;
