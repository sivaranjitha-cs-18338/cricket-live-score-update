"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var __await = (this && this.__await) || function (v) { return this instanceof __await ? (this.v = v, this) : new __await(v); }
var __asyncGenerator = (this && this.__asyncGenerator) || function (thisArg, _arguments, generator) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var g = generator.apply(thisArg, _arguments || []), i, q = [];
    return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i;
    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }
    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }
    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }
    function fulfill(value) { resume("next", value); }
    function reject(value) { resume("throw", value); }
    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }
};
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
var _Bucket_instances, _Bucket_requester, _Bucket_util, _Bucket_cors, _Bucket_serializeResponse;
Object.defineProperty(exports, "__esModule", { value: true });
exports.Bucket = void 0;
const constants_1 = __importDefault(require("../utils/constants"));
const object_1 = require("./object");
const validator_1 = require("../utils/validator");
const error_1 = require("../utils/error");
const stream_1 = require("stream");
const cors_1 = require("./cors");
const mime_types_1 = require("../utils/mime-types");
const util_1 = require("./util");
const { REQ_METHOD, CREDENTIAL_USER, STRATUS_SUFFIX } = constants_1.default;
class Bucket {
    constructor(requester, bucket) {
        var _a;
        _Bucket_instances.add(this);
        _Bucket_requester.set(this, void 0);
        this.auth = true;
        _Bucket_util.set(this, void 0);
        _Bucket_cors.set(this, void 0);
        __classPrivateFieldSet(this, _Bucket_requester, requester, "f");
        if (typeof bucket === 'string') {
            this.bucketDetails = {
                bucket_name: bucket,
                bucket_url: ((_a = __classPrivateFieldGet(this, _Bucket_requester, "f").app) === null || _a === void 0 ? void 0 : _a.config.environment) == 'Development'
                    ? `https://${bucket}-development${STRATUS_SUFFIX}`
                    : `https://${bucket}${STRATUS_SUFFIX}`
            };
        }
        else {
            this.bucketDetails = bucket;
        }
        __classPrivateFieldSet(this, _Bucket_util, new util_1.Util(this), "f");
        __classPrivateFieldSet(this, _Bucket_cors, new cors_1.Cors(this), "f");
    }
    getAuthorizationClient() {
        return __classPrivateFieldGet(this, _Bucket_requester, "f");
    }
    /**
     * Get the name of the bucket.
     * @returns { string } The name of the bucket as a string.
     */
    getName() {
        return this.bucketDetails.bucket_name;
    }
    /**
     * Retrieve a paginated list of objects and their details in the bucket.
     * @param options - Configuration options for pagination, such as folder listing,
     * 				maximum objects, and prefix filters.
     * @access admin
     * @returns { IStratusObjects } An object containing details of the listed objects.
     */
    listPagedObjects(options = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            const param = {
                bucket_name: this.bucketDetails.bucket_name,
                folder_listing: options.folderListing || 'false'
            };
            if (options.orderBy) {
                if (['asc', 'desc'].includes(options.orderBy.toLowerCase())) {
                    param.order_by = options.orderBy.toLocaleLowerCase();
                }
                else {
                    throw new error_1.CatalystStratusError('INVALID_OPTION', 'Invalid value for orderBy. Use "asc" or "desc".');
                }
            }
            if (options.prefix) {
                param.prefix = options.prefix;
            }
            if (options.maxKeys) {
                param.max_keys = options.maxKeys;
            }
            if (options.continuationToken) {
                param.continuation_token = options.continuationToken;
            }
            const request = {
                method: REQ_METHOD.get,
                path: '/bucket/objects',
                qs: param,
                type: "json" /* RequestType.JSON */,
                expecting: "json" /* ResponseType.JSON */,
                catalyst: true,
                track: true,
                user: CREDENTIAL_USER.admin
            };
            const resp = yield __classPrivateFieldGet(this, _Bucket_requester, "f").send(request);
            const objects = resp.data.data;
            const files = objects.contents.map((key) => new object_1.StratusObject(this, key));
            objects.contents = files;
            return objects;
        });
    }
    /**
     * Retrieve objects and their details in the bucket as an iterable.
     * @param prefix - (Optional) A prefix to filter the objects returned.
     * @param maxKeys - (Optional) The maximum number of objects to return per request.
     * @access admin
     * @returns { AsyncGenerator<StratusObject, void> } An asynchronous generator yielding `StratusObject` instances.
     */
    listIterableObjects(options = {}) {
        return __asyncGenerator(this, arguments, function* listIterableObjects_1() {
            do {
                const filesOutput = yield __await(this.listPagedObjects(options));
                for (const key of filesOutput.contents) {
                    yield yield __await(key);
                }
                options.continuationToken = filesOutput.next_continuation_token;
            } while (options.continuationToken);
        });
    }
    /**
     * Fetch detailed information about the bucket.
     * @access admin
     * @returns { IStratusBucket } Containing metadata and configuration details of the bucket.
     */
    getDetails() {
        return __awaiter(this, void 0, void 0, function* () {
            const request = {
                method: REQ_METHOD.get,
                path: '/bucket',
                qs: { bucket_name: this.bucketDetails.bucket_name },
                type: "json" /* RequestType.JSON */,
                expecting: "json" /* ResponseType.JSON */,
                catalyst: true,
                track: true,
                user: CREDENTIAL_USER.admin
            };
            const resp = yield __classPrivateFieldGet(this, _Bucket_requester, "f").send(request);
            return resp.data.data[0];
        });
    }
    /**
     * Delete all the objects in the bucket.
     * @access admin
     * @returns { message: string } Details of the truncate operation.
     */
    truncate() {
        return __awaiter(this, void 0, void 0, function* () {
            const param = {
                bucket_name: this.bucketDetails.bucket_name
            };
            const request = {
                method: REQ_METHOD.delete,
                path: '/bucket/truncate',
                qs: param,
                type: "json" /* RequestType.JSON */,
                expecting: "json" /* ResponseType.JSON */,
                catalyst: true,
                track: true,
                user: CREDENTIAL_USER.admin
            };
            const resp = yield __classPrivateFieldGet(this, _Bucket_requester, "f").send(request);
            return resp.data.data;
        });
    }
    /**
     * Copies an object within the bucket to a specified destination.
     * @param key - The name of the source object to copy.
     * @param destKey - The name of the destination object.
     * @access admin
     * @example
     * ```js
     * const sourceKey = 'sam/out/temp.txt';
     * const destKey = 'out/sam/temp.txt';
     * // invoke copy object operation.
     * const copyObjectRes = await bucket.copyObject(sourceKey, destKey);
     * console.log(copyObjectRes);
     * ```
     * @returns { IStratusObjectCopyRes } The result of the copy operation.
     */
    copyObject(key, destKey) {
        return __awaiter(this, void 0, void 0, function* () {
            yield (0, validator_1.wrapValidatorsWithPromise)(() => {
                (0, validator_1.isNonEmptyString)(key, 'key', true);
                (0, validator_1.isNonEmptyString)(destKey, 'destKey', true);
            }, error_1.CatalystStratusError);
            const _param = {
                bucket_name: this.bucketDetails.bucket_name,
                object_key: key,
                destination: destKey
            };
            const request = {
                method: REQ_METHOD.post,
                path: '/bucket/object/copy',
                qs: _param,
                type: "json" /* RequestType.JSON */,
                expecting: "json" /* ResponseType.JSON */,
                catalyst: true,
                track: true,
                user: CREDENTIAL_USER.admin
            };
            const resp = yield __classPrivateFieldGet(this, _Bucket_requester, "f").send(request);
            return __classPrivateFieldGet(this, _Bucket_instances, "m", _Bucket_serializeResponse).call(this, resp.data.data);
        });
    }
    /**
     * Renames an existing object in the bucket.
     * @param key - The current name of the object to rename.
     * @param destKey - The new name for the object key.
     * @access admin
     * @example
     * ```js
     * const sourceKey = 'sam/out/temp.txt';
     * const destKey = 'out/sam/temp.txt';
     * const renameObjectRes = await bucket.renameObject(sourceKey, destKey);
     * console.log(renameObjectRes);
     * ```
     * @returns { IStratusObjectRenameRes } The result of the rename operation.
     */
    renameObject(key, destKey) {
        return __awaiter(this, void 0, void 0, function* () {
            yield (0, validator_1.wrapValidatorsWithPromise)(() => {
                (0, validator_1.isNonEmptyString)(key, 'key', true);
                (0, validator_1.isNonEmptyString)(destKey, 'destKey', true);
            }, error_1.CatalystStratusError);
            const param = {
                bucket_name: this.bucketDetails.bucket_name,
                current_key: key,
                rename_to: destKey
            };
            const request = {
                method: REQ_METHOD.patch,
                path: '/bucket/object',
                qs: param,
                type: "json" /* RequestType.JSON */,
                expecting: "json" /* ResponseType.JSON */,
                catalyst: true,
                track: true,
                user: CREDENTIAL_USER.admin
            };
            const resp = yield __classPrivateFieldGet(this, _Bucket_requester, "f").send(request);
            return resp.data.data;
        });
    }
    /**
     * Generates a pre-signed URL for the specified object, allowing temporary access.
     * @param key - The name of the object for which the URL is generated.
     * @param urlAction - The HTTP method for the operation (`PUT` or `GET`).
     * @param signedUrlOptions - Optional settings for the URL, such as expiration time or activation period.
     * @access admin
     * @example
     * ```js
     * const key = 'sam/out/temp.txt';
     * const options = {
     *   expiryIn: '3000', // Expiration time in seconds
     *   activeFrom: '23736279382' // Activation start time (timestamp)
     * };
     * const preSignedUrlRes = await bucket.generatePreSignedUrl(key, 'GET', options);
     * console.log(preSignedUrlRes);
     * ```
     * @returns { IStratusPresignedUrlRes } An object containing the pre-signed URL.
     */
    generatePreSignedUrl(key, urlAction, signedUrlOptions = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            yield (0, validator_1.wrapValidatorsWithPromise)(() => {
                (0, validator_1.isNonEmptyString)(key, 'key', true);
                (0, validator_1.isNonEmptyString)(urlAction, 'url_action', true);
            }, error_1.CatalystStratusError);
            const param = {
                bucket_name: this.bucketDetails.bucket_name,
                object_key: key
            };
            if (signedUrlOptions === null || signedUrlOptions === void 0 ? void 0 : signedUrlOptions.activeFrom) {
                param.active_from = signedUrlOptions.activeFrom;
            }
            if (signedUrlOptions === null || signedUrlOptions === void 0 ? void 0 : signedUrlOptions.expiryIn) {
                param.expiry_in_seconds = signedUrlOptions.expiryIn;
            }
            if (urlAction.toLocaleUpperCase() === 'get' && (signedUrlOptions === null || signedUrlOptions === void 0 ? void 0 : signedUrlOptions.versionId)) {
                param.version_id = signedUrlOptions.versionId;
            }
            const request = {
                method: urlAction,
                path: '/bucket/object/signed-url',
                qs: param,
                type: "json" /* RequestType.JSON */,
                expecting: "json" /* ResponseType.JSON */,
                catalyst: true,
                track: true,
                user: CREDENTIAL_USER.admin
            };
            const resp = yield __classPrivateFieldGet(this, _Bucket_requester, "f").send(request);
            return resp.data.data;
        });
    }
    /**
     * Deletes a specified path and all its objects in the bucket.
     * @param path - The path to be deleted, relative to the bucket.
     * @access admin
     * @example
     * ```js
     * const path = 'sam/';
     * // Invoke delete path operation
     * const pathDeleteRes = await bucket.deletePath(path);
     * console.log(pathDeleteRes);
     * ```
     * @returns { IStratusObjectDetails } Details of the deleted objects.
     */
    deletePath(path) {
        return __awaiter(this, void 0, void 0, function* () {
            yield (0, validator_1.wrapValidatorsWithPromise)(() => {
                (0, validator_1.isNonEmptyString)(path, 'object_path', true);
            }, error_1.CatalystStratusError);
            const param = { bucket_name: this.bucketDetails.bucket_name, prefix: path };
            const request = {
                method: REQ_METHOD.delete,
                path: '/bucket/object/prefix',
                qs: param,
                type: "json" /* RequestType.JSON */,
                expecting: "json" /* ResponseType.JSON */,
                catalyst: true,
                track: true,
                user: CREDENTIAL_USER.admin
            };
            const resp = yield __classPrivateFieldGet(this, _Bucket_requester, "f").send(request);
            return resp.data.data;
        });
    }
    /**
     * Clears cached items in the bucket.
     * @param path  - An optional array of paths to clear cache for. If not provided, the entire cache is cleared.
     * @access admin
     * @example
     * ```js
     * const path = ['sam', 'out/sam/temp.txt'];
     * // Invoke purge cache operation
     * const purgeCacheRes = await bucket.purgeCache(path);
     * console.log(purgeCacheRes);
     * ```
     * @returns { IStratusObjectDetails } Details of the cleared cache items.
     */
    purgeCache(path) {
        return __awaiter(this, void 0, void 0, function* () {
            const param = {
                bucket_name: this.bucketDetails.bucket_name
            };
            const request = {
                method: REQ_METHOD.put,
                path: '/bucket/purge-cache',
                qs: param,
                data: path || [],
                type: "json" /* RequestType.JSON */,
                expecting: "json" /* ResponseType.JSON */,
                catalyst: true,
                user: CREDENTIAL_USER.admin
            };
            const resp = yield __classPrivateFieldGet(this, _Bucket_requester, "f").send(request);
            return resp.data.data;
        });
    }
    /**
     * Downloads an object from the bucket.
     * @param key - The unique identifier or path of the object within the bucket to be downloaded.
     * @param getObjectOptions - Optional options for customizing the download:
     *   - `range` (string): Specifies a byte range for partial downloads (e.g., "0-200").
     *   - `versionId` (string): Identifies a specific version of the object, if versioning is enabled.
     * @access admin, user
     * @example
     * ```js
     * const key = 'out/sam/temp.txt';
     * const options = {
     *   versionId: 'bfjd673e2hgh2', // Specify the version ID if needed
     *   range: '0-200' // Download only the first 200 bytes of the file
     * };
     * // Invoke the object download operation
     * const getObjectRes = await bucket.getObject(key, options);
     * ```
     * @returns { Readable } A readable stream of the object (`Readable`).
     */
    getObject(key, { range, versionId } = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            yield (0, validator_1.wrapValidatorsWithPromise)(() => {
                (0, validator_1.isNonEmptyString)(key, 'key', true);
            }, error_1.CatalystStratusError);
            let url = this.bucketDetails.bucket_url;
            const signParam = (yield __classPrivateFieldGet(this, _Bucket_util, "f").getBucketSignature());
            if (signParam !== undefined) {
                url += '/_signed';
                this.auth = false;
            }
            const request = {
                method: REQ_METHOD.get,
                url: url + `/${encodeURI(key)}`,
                qs: Object.assign({ versionId: versionId }, signParam),
                type: "json" /* RequestType.JSON */,
                expecting: "raw" /* ResponseType.RAW */,
                catalyst: false,
                auth: this.auth,
                headers: range ? { Range: `bytes=${range}` } : {},
                external: true,
                user: CREDENTIAL_USER.user
            };
            const resp = yield __classPrivateFieldGet(this, _Bucket_requester, "f").send(request);
            return resp.data;
        });
    }
    /**
     * Deletes a single object from the bucket.
     * @param key - The name of the object to delete.
     * @param versionId - The version ID of the object to delete (optional).
     * @param ttl - The time to live (TTL) in seconds.
     * 				The object will not be deleted immediately but after the specified time (optional).
     * @access admin, user
     * @example
     * ```js
     * const key = 'out/sam/temp.txt';
     * const options = {
     *   versionId: 'bfjd673e2hgh2', // Optional: Specific version ID of the object.
     *   ttl: 300 // Optional: Time to live in seconds.
     * };
     * // Invoke object deletion operation
     * const deleteObjectRes = await bucket.deleteObject(key, options);
     * console.log(deleteObjectRes);
     * ```
     * @returns { Record<string, string> } Containing a message about the deletion operation.
     */
    deleteObject(key, { versionId, ttl } = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            yield (0, validator_1.wrapValidatorsWithPromise)(() => {
                (0, validator_1.isNonEmptyString)(key, 'key', true);
            }, error_1.CatalystStratusError);
            if (__classPrivateFieldGet(this, _Bucket_util, "f")._getUserType() !== 'admin' && __classPrivateFieldGet(this, _Bucket_util, "f")._getUserScope() !== 'admin') {
                const url = this.bucketDetails.bucket_url;
                yield (0, validator_1.wrapValidatorsWithPromise)(() => {
                    (0, validator_1.isNonEmptyString)(key, 'key', true);
                }, error_1.CatalystStratusError);
                const request = {
                    method: REQ_METHOD.delete,
                    url: url + `/${encodeURI(key)}`,
                    qs: Object.assign({ ttl }, (versionId ? { versionId } : { deleteAllVersions: 'true' })),
                    type: "json" /* RequestType.JSON */,
                    expecting: "json" /* ResponseType.JSON */,
                    catalyst: false,
                    external: true,
                    track: true,
                    user: CREDENTIAL_USER.user
                };
                const resp = yield __classPrivateFieldGet(this, _Bucket_requester, "f").send(request);
                return { message: resp.resp.data };
            }
            const objects = [
                {
                    key,
                    versionId
                }
            ];
            return yield this.deleteObjects(objects, ttl);
        });
    }
    /**
     * Deletes multiple objects from the bucket.
     * @param objects - An array of objects to be deleted.
     * @param ttl - The time to live (TTL) in seconds.
     * 				The objects will not be deleted immediately but after the specified time (optional).
     * @access admin
     * @example
     * ```js
     * const objects = [
     *   { key: 'out1/sam1/temp1.txt', versionId: 'jsdbe6738y3bje' },
     *   { key: 'out2/sam2/temp2.txt', versionId: '34mnkejh89f9' }
     * ];
     * const ttl = 1000; // Time to live in seconds.
     * // Invoke objects deletion operation
     * const deleteObjectsRes = await bucket.deleteObjects(objects, ttl);
     * console.log(deleteObjectsRes);
     * ```
     * @returns { Record<string, string> } Containing the deletion status, typically `{ message: 'Objects deleted successfully' }`.
     */
    deleteObjects(objects, ttl) {
        return __awaiter(this, void 0, void 0, function* () {
            yield (0, validator_1.wrapValidatorsWithPromise)(() => {
                (0, validator_1.isNonEmptyArray)(objects, 'objects', true);
            }, error_1.CatalystStratusError);
            const objectArr = objects.map((object) => (Object.assign({ key: object.key }, ((object === null || object === void 0 ? void 0 : object.versionId) ? { version_id: object === null || object === void 0 ? void 0 : object.versionId } : {}))));
            const objectsDetail = {
                objects: objectArr,
                ttl_in_seconds: ttl
            };
            const param = {
                bucket_name: this.bucketDetails.bucket_name
            };
            const request = {
                method: REQ_METHOD.put,
                path: '/bucket/object',
                data: objectsDetail,
                qs: param,
                type: "json" /* RequestType.JSON */,
                expecting: "json" /* ResponseType.JSON */,
                catalyst: true,
                track: true,
                user: CREDENTIAL_USER.admin
            };
            const resp = yield __classPrivateFieldGet(this, _Bucket_requester, "f").send(request);
            return resp.data.data;
        });
    }
    putObject(key, body, uploadOptions) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            yield (0, validator_1.wrapValidatorsWithPromise)(() => {
                (0, validator_1.isNonEmptyString)(key, 'key', true);
                (0, validator_1.isNonNullValue)(body, 'object_body', true);
            }, error_1.CatalystStratusError);
            const contentType = (uploadOptions === null || uploadOptions === void 0 ? void 0 : uploadOptions.contentType) || (0, mime_types_1.getContentType)(key) || 'application/octet-stream';
            let url = this.bucketDetails.bucket_url;
            // Prepare metadata header
            const metaData = (uploadOptions === null || uploadOptions === void 0 ? void 0 : uploadOptions.metaData)
                ? Object.entries(uploadOptions.metaData)
                    .map(([k, v]) => `${k}=${v};`)
                    .join('')
                : undefined;
            const headers = {
                compress: (uploadOptions === null || uploadOptions === void 0 ? void 0 : uploadOptions.compress) || 'false',
                'Content-Type': contentType
            };
            if (uploadOptions === null || uploadOptions === void 0 ? void 0 : uploadOptions.ttl) {
                headers['expires-after'] = uploadOptions.ttl;
            }
            if (typeof (uploadOptions === null || uploadOptions === void 0 ? void 0 : uploadOptions.overwrite) !== 'undefined') {
                headers.overwrite = String(uploadOptions.overwrite);
            }
            if (metaData) {
                headers['x-user-meta'] = metaData;
            }
            const param = {};
            if (uploadOptions === null || uploadOptions === void 0 ? void 0 : uploadOptions.extractUpload) {
                param.extractAndUpload = uploadOptions.extractUpload;
            }
            const signParam = (yield __classPrivateFieldGet(this, _Bucket_util, "f").getBucketSignature());
            if (signParam !== undefined) {
                url += '/_signed';
                this.auth = false;
            }
            // Convert string or Buffer to Readable stream
            if (typeof body === 'string') {
                body = stream_1.Readable.from(Buffer.from(body, 'utf-8'));
            }
            else if (body instanceof Buffer) {
                body = stream_1.Readable.from(body);
            }
            const request = {
                method: REQ_METHOD.put,
                url: url + `/${encodeURI(key)}`,
                data: body,
                qs: Object.assign(Object.assign({}, param), signParam),
                type: "raw" /* RequestType.RAW */,
                expecting: "json" /* ResponseType.JSON */,
                headers,
                catalyst: false,
                auth: this.auth,
                track: true,
                external: true,
                user: CREDENTIAL_USER.user
            };
            const resp = yield __classPrivateFieldGet(this, _Bucket_requester, "f").send(request);
            // If extractUpload is set, expect a task_id in response
            if ((uploadOptions === null || uploadOptions === void 0 ? void 0 : uploadOptions.extractUpload) && ((_a = resp.data) === null || _a === void 0 ? void 0 : _a.task_id)) {
                return { task_id: resp.data.task_id };
            }
            return resp.statusCode === 200;
        });
    }
    // /**
    //  * Download one or more objects in the bucket as zip.
    //  * @param objects to be downloaded.
    //  * @param prefix to download given prefixed objects.
    //  * @param continuationToken to get the next set of objects.
    //  * @returns
    //  */
    // async getMultipleObjects(
    // 	{
    // 		objects,
    // 		prefix
    // 	}: {
    // 		objects?: Array<string> | '*' | 'Top';
    // 		prefix?: Array<string>;
    // 	},
    // 	continuationToken?: string
    // ): Promise<{ data: IncomingMessage; continuationToken?: string }> {
    // 	const url = this.bucketDetails.bucket_url;
    // 	let inputData;
    // 	if (objects instanceof Array) {
    // 		const objList: Array<{ key: string }> = objects.map((key) => ({ key }));
    // 		inputData = { objects: objList, prefix };
    // 	} else {
    // 		inputData = { objects, prefix };
    // 	}
    // 	const request: IRequestConfig = {
    // 		method: REQ_METHOD.post,
    // 		url: url + `/?zip`,
    // 		data: inputData,
    // 		qs: { continuationToken },
    // 		type: RequestType.JSON,
    // 		expecting: ResponseType.RAW,
    // 		catalyst: false,
    // 		track: true,
    // 		external: true,
    // 		user: CREDENTIAL_USER.user
    // 	};
    // 	const resp = await this.#requester.send(request);
    // 	const finalRes = {
    // 		data: resp.data as IncomingMessage,
    // 		continuationToken: resp.headers['Continuation-Token'] as string
    // 	};
    // 	return finalRes;
    // }
    /**
     * Extracts a given zip object and uploads all the files inside it as individual objects to the same bucket.
     * @param key - The name of the zip object to unzip.
     * @param destPath - The destination path where the unzipped files will be stored.
     * @access admin
     * @example
     * ```js
     * const key = 'out/sam/temp.zip';
     * const destPath = 'sam/out/';
     * // Invoke zip extraction operation
     * const unzipObjectRes = await bucket.unzipObject(key, destPath);
     * console.log(unzipObjectRes);
     * ```
     * @returns { IStratusUnzipRes } Containing details about the extracted objects.
     */
    unzipObject(key, destPath) {
        return __awaiter(this, void 0, void 0, function* () {
            yield (0, validator_1.wrapValidatorsWithPromise)(() => {
                (0, validator_1.isNonEmptyString)(key, 'key', true);
                (0, validator_1.isNonEmptyString)(destPath, 'dest_path', true);
            }, error_1.CatalystStratusError);
            const intrlparam = {
                bucket_name: this.bucketDetails.bucket_name,
                object_key: key,
                destination: destPath
            };
            const request = {
                method: REQ_METHOD.post,
                path: '/bucket/object/zip-extract',
                qs: intrlparam,
                type: "json" /* RequestType.JSON */,
                expecting: "json" /* ResponseType.JSON */,
                catalyst: true,
                track: true,
                user: CREDENTIAL_USER.admin
            };
            const resp = yield __classPrivateFieldGet(this, _Bucket_requester, "f").send(request);
            return __classPrivateFieldGet(this, _Bucket_instances, "m", _Bucket_serializeResponse).call(this, resp.data.data);
        });
    }
    /**
     * Retrieves the status of an unzip operation.
     * @param key - The name of the zip object that was being extracted.
     * @param taskId - The ID of the unzip task to check the status for.
     * @access admin
     * @example
     * ```js
     * const key = 'out/sam/temp.zip';
     * const taskId = '4384292001930123';
     * // Get the status of zip extraction
     * const getUnzipStatusRes = await bucket.getUnzipStatus(key, taskId);
     * console.log(getUnzipStatusRes);
     * ```
     * @returns { IStratusUnzipStatus } Containing the status of the unzip operation.
     */
    getUnzipStatus(key, taskId) {
        return __awaiter(this, void 0, void 0, function* () {
            yield (0, validator_1.wrapValidatorsWithPromise)(() => {
                (0, validator_1.isNonEmptyString)(key, 'key', true);
                (0, validator_1.isNonEmptyString)(taskId, 'task_id', true);
            }, error_1.CatalystStratusError);
            const _param = {
                bucket_name: this.bucketDetails.bucket_name,
                object_key: key,
                task_id: taskId
            };
            const request = {
                method: REQ_METHOD.get,
                path: '/bucket/object/zip-extract/status',
                qs: _param,
                type: "json" /* RequestType.JSON */,
                expecting: "json" /* ResponseType.JSON */,
                catalyst: true,
                track: true,
                user: CREDENTIAL_USER.admin
            };
            const resp = yield __classPrivateFieldGet(this, _Bucket_requester, "f").send(request);
            return resp.data.data;
        });
    }
    /**
     * Retrieves the CORS details of the bucket.
     * @access admin
     * @returns {Array<IStratusCorsRes>} The CORS configuration details for the bucket.
     */
    getCors() {
        return __awaiter(this, void 0, void 0, function* () {
            const corsDetails = __classPrivateFieldGet(this, _Bucket_cors, "f").getCors();
            return corsDetails;
        });
    }
    /**
     * Checks whether a specific object exists in the bucket and whether the given user has permission to access it.
     * @param key - The name that uniquely identifies the object within the bucket.
     * @param versionId - The version ID of the object (for versioned buckets, optional).
     * @param throwErr - Whether to throw an error if the object does not exist or is inaccessible.
     * 					 Defaults to `false`.
     * @access admin, user
     * @example
     * ```js
     * const key = 'out1/sam1/temp1.txt';
     * // Check the availability of the object.
     * const headObjectRes = await bucket.headObject(key, { versionId: 'dskjhgdfue627', throwErr: false });
     * console.log(headObjectRes);
     * ```
     * @returns {boolean} `true` if the object exists and is accessible, `false` otherwise.
     */
    headObject(key, { versionId, throwErr } = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            yield (0, validator_1.wrapValidatorsWithPromise)(() => {
                (0, validator_1.isNonEmptyString)(key, 'key', true);
            }, error_1.CatalystStratusError);
            try {
                if (__classPrivateFieldGet(this, _Bucket_util, "f")._getUserType() !== 'admin' && __classPrivateFieldGet(this, _Bucket_util, "f")._getUserScope() !== 'admin') {
                    const params = {
                        versionId
                    };
                    const request = {
                        method: REQ_METHOD.head,
                        url: this.bucketDetails.bucket_url + `/${encodeURI(key)}`,
                        qs: params,
                        type: "json" /* RequestType.JSON */,
                        expecting: "json" /* ResponseType.JSON */,
                        catalyst: false,
                        external: true,
                        user: CREDENTIAL_USER.user
                    };
                    const resp = yield __classPrivateFieldGet(this, _Bucket_requester, "f").send(request);
                    return resp.statusCode === 200;
                }
                const params = {
                    bucket_name: this.bucketDetails.bucket_name,
                    object_key: key,
                    version_id: versionId
                };
                const request = {
                    method: REQ_METHOD.head,
                    path: '/bucket/object',
                    qs: params,
                    type: "json" /* RequestType.JSON */,
                    expecting: "json" /* ResponseType.JSON */,
                    catalyst: true,
                    track: true,
                    user: CREDENTIAL_USER.admin
                };
                const resp = yield __classPrivateFieldGet(this, _Bucket_requester, "f").send(request);
                return resp.statusCode === 200;
            }
            catch (err) {
                if (!throwErr) {
                    const status = err.statusCode;
                    if (status === 404 || status === 403 || status === 400) {
                        return false;
                    }
                }
                throw err;
            }
        });
    }
    /**
     * Initiates a multipart upload for an object in the bucket.
     * @param key - The name of the object to upload.
     * @access admin, user
     * @returns {IStratusInitiateUpload} Details of the initiated upload.
     */
    initiateMultipartUpload(key, options) {
        return __awaiter(this, void 0, void 0, function* () {
            yield (0, validator_1.wrapValidatorsWithPromise)(() => {
                (0, validator_1.isNonEmptyString)(key, 'key', true);
            }, error_1.CatalystStratusError);
            const contentType = (0, mime_types_1.getContentType)(key);
            let url = this.bucketDetails.bucket_url;
            const signParam = (yield __classPrivateFieldGet(this, _Bucket_util, "f").getBucketSignature());
            if (signParam !== undefined) {
                url += '/_signed';
                this.auth = false;
            }
            const request = {
                method: REQ_METHOD.put,
                url: url + `/${encodeURI(key)}?multipart`,
                qs: Object.assign({}, signParam),
                type: "json" /* RequestType.JSON */,
                expecting: "json" /* ResponseType.JSON */,
                headers: {
                    compress: (options === null || options === void 0 ? void 0 : options.compress) || 'false',
                    'Content-Type': (options === null || options === void 0 ? void 0 : options.contentType) || contentType
                },
                auth: this.auth,
                catalyst: false,
                external: true,
                user: CREDENTIAL_USER.user
            };
            const resp = yield __classPrivateFieldGet(this, _Bucket_requester, "f").send(request);
            return resp.data;
        });
    }
    /**
     * Uploads an individual part of a file as part of a multipart upload.
     * @param key - The name of the object.
     * @param uploadId - The ID of the specific upload.
     * @param body - The content to be uploaded (can be a `Stream` or `Buffer`).
     * @param partNumber - The part number (must be between 1 and 1000) indicating the order of the part.
     * @param overwrite - Whether to overwrite the part if it already exists (defaults to 'false').
     * @access admin, user
     * @returns {boolean} `true` if the part is successfully uploaded, `false` otherwise.
     */
    uploadPart(key, uploadId, body, partNumber, options) {
        return __awaiter(this, void 0, void 0, function* () {
            if (body instanceof Buffer) {
                body = stream_1.Readable.from(body);
            }
            let url = this.bucketDetails.bucket_url;
            const signParam = yield __classPrivateFieldGet(this, _Bucket_util, "f").getBucketSignature();
            let param = { uploadId, partNumber };
            if (signParam !== undefined) {
                url += '/_signed';
                this.auth = false;
                param = Object.assign({}, param, signParam);
            }
            const request = {
                method: REQ_METHOD.put,
                url: url + `/${encodeURI(key)}`,
                data: body,
                qs: param,
                type: "raw" /* RequestType.RAW */,
                headers: {
                    compress: (options === null || options === void 0 ? void 0 : options.compress) || 'false',
                    overwrite: (options === null || options === void 0 ? void 0 : options.overwrite) || 'false'
                },
                expecting: "json" /* ResponseType.JSON */,
                catalyst: false,
                external: true,
                auth: this.auth,
                user: CREDENTIAL_USER.user
            };
            const resp = yield __classPrivateFieldGet(this, _Bucket_requester, "f").send(request);
            return resp.statusCode === 200;
        });
    }
    /**
     * Completes the multipart upload after all parts have been uploaded.
     * @param key - The name of the object.
     * @param uploadId - The ID of the specific upload.
     * @access admin, user
     * @returns {boolean} `true` if the upload is completed successfully, `false` otherwise.
     */
    completeMultipartUpload(key, uploadId) {
        return __awaiter(this, void 0, void 0, function* () {
            let url = this.bucketDetails.bucket_url;
            const signParam = (yield __classPrivateFieldGet(this, _Bucket_util, "f").getBucketSignature());
            if (signParam !== undefined) {
                url += '/_signed';
                this.auth = false;
            }
            const request = {
                method: REQ_METHOD.put,
                url: url + `/${encodeURI(key)}?completeMultipart`,
                qs: Object.assign({ uploadId: uploadId }, signParam),
                type: "json" /* RequestType.JSON */,
                expecting: "json" /* ResponseType.JSON */,
                catalyst: false,
                auth: this.auth,
                track: true,
                external: true,
                user: CREDENTIAL_USER.user
            };
            const resp = yield __classPrivateFieldGet(this, _Bucket_requester, "f").send(request);
            return resp.statusCode === 202;
        });
    }
    /**
     * Retrieves a summary of the uploaded parts for a multipart upload.
     * @param key - The name of the object.
     * @param uploadId - The ID of the specific upload.
     * @access admin, user
     * @returns {IStratusMultipartSummaryRes} A summary of the uploaded parts.
     */
    getMultipartUploadSummary(key, uploadId) {
        return __awaiter(this, void 0, void 0, function* () {
            let url = this.bucketDetails.bucket_url;
            const signParam = (yield __classPrivateFieldGet(this, _Bucket_util, "f").getBucketSignature());
            if (signParam !== undefined) {
                url += '/_signed';
                this.auth = false;
            }
            const request = {
                method: REQ_METHOD.get,
                url: url + `/${encodeURI(key)}?multipartSummary`,
                qs: Object.assign({ uploadId }, signParam),
                type: "json" /* RequestType.JSON */,
                expecting: "json" /* ResponseType.JSON */,
                catalyst: false,
                auth: this.auth,
                track: true,
                external: true,
                user: CREDENTIAL_USER.user
            };
            const resp = yield __classPrivateFieldGet(this, _Bucket_requester, "f").send(request);
            return resp.data;
        });
    }
    /**
     * Get an object instance.
     * @param key - The name of the object.
     * @access admin, user
     * @returns {StratusObject} An instance of the object.
     * @throws {CatalystStratusError} If the `key` is invalid.
     */
    object(key) {
        if (!(0, validator_1.isNonEmptyString)(key)) {
            throw new error_1.CatalystStratusError('invalid-argument', 'Value provided for key must be a non empty String', key);
        }
        return new object_1.StratusObject(this, key);
    }
    toString() {
        return JSON.stringify(this.bucketDetails);
    }
    toJSON() {
        return this.bucketDetails;
    }
}
exports.Bucket = Bucket;
_Bucket_requester = new WeakMap(), _Bucket_util = new WeakMap(), _Bucket_cors = new WeakMap(), _Bucket_instances = new WeakSet(), _Bucket_serializeResponse = function _Bucket_serializeResponse(resp) {
    const { object_key: key } = resp, others = __rest(resp, ["object_key"]);
    return Object.assign({ key }, others);
};
