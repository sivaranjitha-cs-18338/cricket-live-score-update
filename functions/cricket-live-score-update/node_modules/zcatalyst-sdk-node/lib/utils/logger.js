"use strict";
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _Logger_instances, _Logger_getTimestamp, _Logger_logToConsole, _Logger_resetLogLevels;
Object.defineProperty(exports, "__esModule", { value: true });
exports.LOGGER = exports.LEVEL = void 0;
const console_1 = require("console");
/**
 * The `ZCLogger` supports the following log levels based on the precedence, as the level with the highest values will have the most precedence.
 * i.e. the log level acts as a minimum threshold and allows the logs with levels equal to or higher to be logged.
 *
 * For Example, if we set the log level to WARN(4) the levels WARN(4) and ERROR(5) will be logged as they are equal to or higher than the
 * threshold set by log level which is WARN(4). Whereas the logs INFO(3), DEBUG(2) and FINE(1) won't be logged as their level is lesser than the
 * set threshold
 *
 * ```md
 * | Level | Precedence |
 * |-------|------------|
 * | NONE  | INF        |
 * | ALL   | 0          |
 * | FINE  | 1          |
 * | DEBUG | 2          |
 * | INFO  | 3          |
 * | WARN  | 4          |
 * | ERROR | 5          |
 * ```
 */
var LEVEL;
(function (LEVEL) {
    LEVEL["NONE"] = "none";
    LEVEL["ALL"] = "all";
    LEVEL["FINE"] = "fine";
    LEVEL["DEBUG"] = "debug";
    LEVEL["INFO"] = "info";
    LEVEL["WARN"] = "warn";
    LEVEL["ERROR"] = "error";
})(LEVEL = exports.LEVEL || (exports.LEVEL = {}));
class Logger {
    constructor(options) {
        _Logger_instances.add(this);
        this.logOptions = {
            enable_debug: (options === null || options === void 0 ? void 0 : options.enable_debug) || false,
            enable_error: (options === null || options === void 0 ? void 0 : options.enable_error) || false,
            enable_info: (options === null || options === void 0 ? void 0 : options.enable_info) || false,
            enable_warn: (options === null || options === void 0 ? void 0 : options.enable_warn) || false,
            enable_fine: (options === null || options === void 0 ? void 0 : options.enable_fine) || false
        };
    }
    info(message) {
        if (this.logOptions.enable_info) {
            __classPrivateFieldGet(this, _Logger_instances, "m", _Logger_logToConsole).call(this, `[INFO ] [${__classPrivateFieldGet(this, _Logger_instances, "m", _Logger_getTimestamp).call(this)}] : ${message}`);
        }
    }
    warn(message) {
        if (this.logOptions.enable_warn) {
            __classPrivateFieldGet(this, _Logger_instances, "m", _Logger_logToConsole).call(this, `[WARN ] [${__classPrivateFieldGet(this, _Logger_instances, "m", _Logger_getTimestamp).call(this)}] : ${message}`);
        }
    }
    error(message) {
        if (this.logOptions.enable_error) {
            __classPrivateFieldGet(this, _Logger_instances, "m", _Logger_logToConsole).call(this, `[ERROR] [${__classPrivateFieldGet(this, _Logger_instances, "m", _Logger_getTimestamp).call(this)}] : ${message}`);
        }
    }
    debug(message) {
        if (this.logOptions.enable_debug) {
            __classPrivateFieldGet(this, _Logger_instances, "m", _Logger_logToConsole).call(this, `[DEBUG] [${__classPrivateFieldGet(this, _Logger_instances, "m", _Logger_getTimestamp).call(this)}] : ${message}`);
        }
    }
    fine(message) {
        if (this.logOptions.enable_fine) {
            __classPrivateFieldGet(this, _Logger_instances, "m", _Logger_logToConsole).call(this, `[FINE ] [${__classPrivateFieldGet(this, _Logger_instances, "m", _Logger_getTimestamp).call(this)}] : ${message}`);
        }
    }
    /**
     * Set the log level for the logger.
     * @param level the log level to set. Defaults to {@link LEVEL.NONE}
     * @returns Logger instance
     */
    setLogLevel(level = LEVEL.NONE) {
        // reset log levels
        __classPrivateFieldGet(this, _Logger_instances, "m", _Logger_resetLogLevels).call(this);
        switch (level) {
            case LEVEL.ALL:
            case LEVEL.FINE:
                this.logOptions.enable_fine = true;
            // eslint-disable-next-line no-fallthrough
            case LEVEL.DEBUG:
                this.logOptions.enable_debug = true;
            // eslint-disable-next-line no-fallthrough
            case LEVEL.INFO:
                this.logOptions.enable_info = true;
            // eslint-disable-next-line no-fallthrough
            case LEVEL.WARN:
                this.logOptions.enable_warn = true;
            // eslint-disable-next-line no-fallthrough
            case LEVEL.ERROR:
                this.logOptions.enable_error = true;
                break;
            case LEVEL.NONE: {
                this.logOptions = {
                    enable_debug: false,
                    enable_error: false,
                    enable_info: false,
                    enable_warn: false,
                    enable_fine: false
                };
                break;
            }
        }
        return this;
    }
}
_Logger_instances = new WeakSet(), _Logger_getTimestamp = function _Logger_getTimestamp() {
    return new Date().toISOString();
}, _Logger_logToConsole = function _Logger_logToConsole(message) {
    (0, console_1.log)(message);
}, _Logger_resetLogLevels = function _Logger_resetLogLevels() {
    this.logOptions = {
        enable_debug: false,
        enable_error: false,
        enable_info: false,
        enable_warn: false,
        enable_fine: false
    };
};
const _logLvl = process.env.ZC_LOG_LVL || 'NONE';
const processLogLvl = LEVEL[_logLvl];
exports.LOGGER = new Logger().setLogLevel(processLogLvl);
